"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts":
/*!*****************************************!*\
  !*** ./src/hooks/useOphiraWebSocket.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOphiraWebSocket: function() { return /* binding */ useOphiraWebSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/medicalStore */ \"(app-pages-browser)/./src/stores/medicalStore.ts\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\nfunction useOphiraWebSocket() {\n    let { enabled = true, sessionId, autoReconnect = true, reconnectInterval = 5000, maxReconnectAttempts = 5 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        connectionStatus: \"disconnected\",\n        lastMessage: null,\n        error: null\n    });\n    const websocketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isManuallyClosedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Medical store actions\n    const { updateVitalSigns, addSensorReading, updateSensorStatus, addAlert, addHealthAnalysis } = (0,_stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__.useMedicalStore)();\n    // Handle incoming WebSocket messages\n    const handleMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        try {\n            const data = JSON.parse(event.data);\n            setState((prev)=>({\n                    ...prev,\n                    lastMessage: data\n                }));\n            // Route messages to appropriate store actions\n            switch(data.type){\n                case \"ping\":\n                    // Respond to server ping with pong\n                    if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\n                        websocketRef.current.send(JSON.stringify({\n                            type: \"pong\",\n                            timestamp: new Date().toISOString()\n                        }));\n                    }\n                    break;\n                case \"vital_signs\":\n                    if (data.data) {\n                        updateVitalSigns(data.data);\n                    }\n                    break;\n                case \"sensor_update\":\n                    if (data.data) {\n                        if (data.data.reading) {\n                            addSensorReading(data.data.reading);\n                        }\n                        if (data.data.status) {\n                            updateSensorStatus(data.data.status);\n                        }\n                    }\n                    break;\n                case \"alert\":\n                    if (data.data) {\n                        addAlert(data.data);\n                        // Show toast notification for alerts\n                        const alertType = data.data.type || \"info\";\n                        const message = data.data.message || \"New medical alert\";\n                        if (alertType === \"critical\" || alertType === \"emergency\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 10000,\n                                icon: \"\\uD83D\\uDEA8\"\n                            });\n                        } else if (alertType === \"warning\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 6000,\n                                icon: \"⚠️\"\n                            });\n                        } else {\n                            (0,react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(message, {\n                                duration: 4000,\n                                icon: \"ℹ️\"\n                            });\n                        }\n                    }\n                    break;\n                case \"chat_message\":\n                    // Handle chat messages (could be routed to a chat store)\n                    console.log(\"Chat message received:\", data.data);\n                    break;\n                case \"agent_status\":\n                    // Handle agent status updates\n                    console.log(\"Agent status update:\", data.data);\n                    break;\n                default:\n                    console.log(\"Unknown WebSocket message type:\", data.type);\n            }\n        } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n        }\n    }, [\n        updateVitalSigns,\n        addSensorReading,\n        updateSensorStatus,\n        addAlert,\n        addHealthAnalysis\n    ]);\n    // Handle WebSocket connection open\n    const handleOpen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"WebSocket connected\");\n        setState((prev)=>({\n                ...prev,\n                isConnected: true,\n                connectionStatus: \"connected\",\n                error: null\n            }));\n        // Reset reconnection attempts on successful connection\n        reconnectAttemptsRef.current = 0;\n        // Only show success toast if we were previously disconnected\n        if (reconnectAttemptsRef.current > 0) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].success(\"Reconnected to Ophira AI\", {\n                duration: 2000,\n                icon: \"\\uD83D\\uDD17\"\n            });\n        }\n    }, []);\n    // Handle WebSocket errors\n    const handleError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.error(\"WebSocket error:\", event);\n        // Only update state if we're not already in an error state to prevent loops\n        setState((prev)=>{\n            if (prev.connectionStatus !== \"error\") {\n                return {\n                    ...prev,\n                    error: \"WebSocket connection error\",\n                    connectionStatus: \"error\"\n                };\n            }\n            return prev;\n        });\n    }, []);\n    // Handle WebSocket connection close\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.log(\"WebSocket closed:\", event.code, event.reason);\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n        // Only attempt reconnection if not manually closed and auto-reconnect is enabled\n        // Add additional checks to prevent infinite loops\n        if (!isManuallyClosedRef.current && autoReconnect && enabled && sessionId && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            // Only try to reconnect if the close wasn't due to an error state\n            if (event.code !== 1006 && event.code !== 1000) {\n                setState((prev)=>({\n                        ...prev,\n                        connectionStatus: \"reconnecting\"\n                    }));\n                // Clear any existing timeout\n                if (reconnectTimeoutRef.current) {\n                    clearTimeout(reconnectTimeoutRef.current);\n                }\n                reconnectTimeoutRef.current = setTimeout(()=>{\n                    reconnectAttemptsRef.current += 1;\n                    console.log(\"Attempting to reconnect... (\".concat(reconnectAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \")\"));\n                    connect();\n                }, reconnectInterval * reconnectAttemptsRef.current); // Exponential backoff\n            }\n        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            console.error(\"Max reconnection attempts reached\");\n            setState((prev)=>({\n                    ...prev,\n                    error: \"Failed to reconnect after maximum attempts\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        autoReconnect,\n        enabled,\n        sessionId,\n        maxReconnectAttempts,\n        reconnectInterval,\n        connect\n    ]);\n    // Connect to WebSocket\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!enabled || !sessionId) return;\n        // Close existing connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n        }\n        setState((prev)=>({\n                ...prev,\n                connectionStatus: \"connecting\",\n                error: null\n            }));\n        try {\n            const ws = (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createWebSocketConnection)(sessionId);\n            ws.onopen = handleOpen;\n            ws.onmessage = handleMessage;\n            ws.onerror = handleError;\n            ws.onclose = handleClose;\n            websocketRef.current = ws;\n            isManuallyClosedRef.current = false;\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    error: error instanceof Error ? error.message : \"Failed to connect\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        enabled,\n        sessionId,\n        handleOpen,\n        handleMessage,\n        handleError,\n        handleClose\n    ]);\n    // Disconnect from WebSocket\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        isManuallyClosedRef.current = true;\n        // Clear reconnection timeout\n        if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n            reconnectTimeoutRef.current = null;\n        }\n        // Close WebSocket connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n    }, []);\n    // Send message through WebSocket\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        if (websocketRef.current && state.isConnected) {\n            try {\n                websocketRef.current.send(JSON.stringify(message));\n                return true;\n            } catch (error) {\n                console.error(\"Failed to send WebSocket message:\", error);\n                return false;\n            }\n        }\n        return false;\n    }, [\n        state.isConnected\n    ]);\n    // Effect to handle connection lifecycle\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (enabled && sessionId) {\n            connect();\n        } else {\n            disconnect();\n        }\n        // Cleanup on unmount\n        return ()=>{\n            disconnect();\n        };\n    }, [\n        enabled,\n        sessionId,\n        connect,\n        disconnect\n    ]);\n    // Cleanup timeouts on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n            }\n        };\n    }, []);\n    return {\n        ...state,\n        connect,\n        disconnect,\n        sendMessage,\n        reconnect: ()=>{\n            reconnectAttemptsRef.current = 0;\n            connect();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBRVQ7QUFDRjtBQUNsQjtBQWlCN0IsU0FBU087UUFBbUIsRUFDakNDLFVBQVUsSUFBSSxFQUNkQyxTQUFTLEVBQ1RDLGdCQUFnQixJQUFJLEVBQ3BCQyxvQkFBb0IsSUFBSSxFQUN4QkMsdUJBQXVCLENBQUMsRUFDRSxHQU5PLGlFQU1KLENBQUM7SUFDOUIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFpQjtRQUNqRGEsYUFBYTtRQUNiQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsZUFBZWxCLDZDQUFNQSxDQUFtQjtJQUM5QyxNQUFNbUIsc0JBQXNCbkIsNkNBQU1BLENBQXdCO0lBQzFELE1BQU1vQix1QkFBdUJwQiw2Q0FBTUEsQ0FBQztJQUNwQyxNQUFNcUIsc0JBQXNCckIsNkNBQU1BLENBQUM7SUFFbkMsd0JBQXdCO0lBQ3hCLE1BQU0sRUFDSnNCLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxrQkFBa0IsRUFDbEJDLFFBQVEsRUFDUkMsaUJBQWlCLEVBQ2xCLEdBQUd2QixxRUFBZUE7SUFFbkIscUNBQXFDO0lBQ3JDLE1BQU13QixnQkFBZ0J6QixrREFBV0EsQ0FBQyxDQUFDMEI7UUFDakMsSUFBSTtZQUNGLE1BQU1DLE9BQXVCQyxLQUFLQyxLQUFLLENBQUNILE1BQU1DLElBQUk7WUFFbERoQixTQUFTbUIsQ0FBQUEsT0FBUztvQkFDaEIsR0FBR0EsSUFBSTtvQkFDUGhCLGFBQWFhO2dCQUNmO1lBRUEsOENBQThDO1lBQzlDLE9BQVFBLEtBQUtJLElBQUk7Z0JBQ2YsS0FBSztvQkFDSCxtQ0FBbUM7b0JBQ25DLElBQUlmLGFBQWFnQixPQUFPLElBQUloQixhQUFhZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTt3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Z0IsT0FBTyxHQUFHO1FBQ3pCO1FBRUFyQixTQUFTbUIsQ0FBQUEsT0FBUztnQkFDaEIsR0FBR0EsSUFBSTtnQkFDUGxCLGFBQWE7Z0JBQ2JDLGtCQUFrQjtZQUNwQjtJQUNGLEdBQUcsRUFBRTtJQUVMLGlDQUFpQztJQUNqQyxNQUFNcUQsY0FBY2xFLGtEQUFXQSxDQUFDLENBQUM0QztRQUMvQixJQUFJNUIsYUFBYWdCLE9BQU8sSUFBSXRCLE1BQU1FLFdBQVcsRUFBRTtZQUM3QyxJQUFJO2dCQUNGSSxhQUFhZ0IsT0FBTyxDQUFDSSxJQUFJLENBQUNSLEtBQUtTLFNBQVMsQ0FBQ087Z0JBQ3pDLE9BQU87WUFDVCxFQUFFLE9BQU83QixPQUFPO2dCQUNkZ0MsUUFBUWhDLEtBQUssQ0FBQyxxQ0FBcUNBO2dCQUNuRCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVCxHQUFHO1FBQUNMLE1BQU1FLFdBQVc7S0FBQztJQUV0Qix3Q0FBd0M7SUFDeENmLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSVEsV0FBV0MsV0FBVztZQUN4Qm1EO1FBQ0YsT0FBTztZQUNMUTtRQUNGO1FBRUEscUJBQXFCO1FBQ3JCLE9BQU87WUFDTEE7UUFDRjtJQUNGLEdBQUc7UUFBQzVEO1FBQVNDO1FBQVdtRDtRQUFTUTtLQUFXO0lBRTVDLDhCQUE4QjtJQUM5QnBFLGdEQUFTQSxDQUFDO1FBQ1IsT0FBTztZQUNMLElBQUlvQixvQkFBb0JlLE9BQU8sRUFBRTtnQkFDL0J1QixhQUFhdEMsb0JBQW9CZSxPQUFPO1lBQzFDO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0wsR0FBR3RCLEtBQUs7UUFDUitDO1FBQ0FRO1FBQ0FDO1FBQ0FDLFdBQVc7WUFDVGpELHFCQUFxQmMsT0FBTyxHQUFHO1lBQy9CeUI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU9waGlyYVdlYlNvY2tldC50cz80YmUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBXZWJTb2NrZXRFdmVudCB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgdXNlTWVkaWNhbFN0b3JlIH0gZnJvbSAnQC9zdG9yZXMvbWVkaWNhbFN0b3JlJztcbmltcG9ydCB7IGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24gfSBmcm9tICdAL2xpYi9hcGknO1xuaW1wb3J0IHRvYXN0IGZyb20gJ3JlYWN0LWhvdC10b2FzdCc7XG5cbmludGVyZmFjZSBVc2VPcGhpcmFXZWJTb2NrZXRPcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIHNlc3Npb25JZD86IHN0cmluZztcbiAgYXV0b1JlY29ubmVjdD86IGJvb2xlYW47XG4gIHJlY29ubmVjdEludGVydmFsPzogbnVtYmVyO1xuICBtYXhSZWNvbm5lY3RBdHRlbXB0cz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFdlYlNvY2tldFN0YXRlIHtcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIGNvbm5lY3Rpb25TdGF0dXM6ICdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCcgfCAnZXJyb3InIHwgJ3JlY29ubmVjdGluZyc7XG4gIGxhc3RNZXNzYWdlOiBXZWJTb2NrZXRFdmVudCB8IG51bGw7XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlT3BoaXJhV2ViU29ja2V0KHtcbiAgZW5hYmxlZCA9IHRydWUsXG4gIHNlc3Npb25JZCxcbiAgYXV0b1JlY29ubmVjdCA9IHRydWUsXG4gIHJlY29ubmVjdEludGVydmFsID0gNTAwMCxcbiAgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSA1XG59OiBVc2VPcGhpcmFXZWJTb2NrZXRPcHRpb25zID0ge30pIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXZWJTb2NrZXRTdGF0ZT4oe1xuICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJyxcbiAgICBsYXN0TWVzc2FnZTogbnVsbCxcbiAgICBlcnJvcjogbnVsbFxuICB9KTtcblxuICBjb25zdCB3ZWJzb2NrZXRSZWYgPSB1c2VSZWY8V2ViU29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlY29ubmVjdFRpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVjb25uZWN0QXR0ZW1wdHNSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGlzTWFudWFsbHlDbG9zZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIC8vIE1lZGljYWwgc3RvcmUgYWN0aW9uc1xuICBjb25zdCB7XG4gICAgdXBkYXRlVml0YWxTaWducyxcbiAgICBhZGRTZW5zb3JSZWFkaW5nLFxuICAgIHVwZGF0ZVNlbnNvclN0YXR1cyxcbiAgICBhZGRBbGVydCxcbiAgICBhZGRIZWFsdGhBbmFseXNpc1xuICB9ID0gdXNlTWVkaWNhbFN0b3JlKCk7XG5cbiAgLy8gSGFuZGxlIGluY29taW5nIFdlYlNvY2tldCBtZXNzYWdlc1xuICBjb25zdCBoYW5kbGVNZXNzYWdlID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YTogV2ViU29ja2V0RXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGxhc3RNZXNzYWdlOiBkYXRhXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFJvdXRlIG1lc3NhZ2VzIHRvIGFwcHJvcHJpYXRlIHN0b3JlIGFjdGlvbnNcbiAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BpbmcnOlxuICAgICAgICAgIC8vIFJlc3BvbmQgdG8gc2VydmVyIHBpbmcgd2l0aCBwb25nXG4gICAgICAgICAgaWYgKHdlYnNvY2tldFJlZi5jdXJyZW50ICYmIHdlYnNvY2tldFJlZi5jdXJyZW50LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3BvbmcnLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAndml0YWxfc2lnbnMnOlxuICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIHVwZGF0ZVZpdGFsU2lnbnMoZGF0YS5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ3NlbnNvcl91cGRhdGUnOlxuICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEucmVhZGluZykge1xuICAgICAgICAgICAgICBhZGRTZW5zb3JSZWFkaW5nKGRhdGEuZGF0YS5yZWFkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVNlbnNvclN0YXR1cyhkYXRhLmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ2FsZXJ0JzpcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBhZGRBbGVydChkYXRhLmRhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG93IHRvYXN0IG5vdGlmaWNhdGlvbiBmb3IgYWxlcnRzXG4gICAgICAgICAgICBjb25zdCBhbGVydFR5cGUgPSBkYXRhLmRhdGEudHlwZSB8fCAnaW5mbyc7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZGF0YS5kYXRhLm1lc3NhZ2UgfHwgJ05ldyBtZWRpY2FsIGFsZXJ0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGFsZXJ0VHlwZSA9PT0gJ2NyaXRpY2FsJyB8fCBhbGVydFR5cGUgPT09ICdlbWVyZ2VuY3knKSB7XG4gICAgICAgICAgICAgIHRvYXN0LmVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwMDAsXG4gICAgICAgICAgICAgICAgaWNvbjogJ/CfmqgnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGVydFR5cGUgPT09ICd3YXJuaW5nJykge1xuICAgICAgICAgICAgICB0b2FzdC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDYwMDAsXG4gICAgICAgICAgICAgICAgaWNvbjogJ+KaoO+4jydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b2FzdChtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDQwMDAsXG4gICAgICAgICAgICAgICAgaWNvbjogJ+KEue+4jydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdjaGF0X21lc3NhZ2UnOlxuICAgICAgICAgIC8vIEhhbmRsZSBjaGF0IG1lc3NhZ2VzIChjb3VsZCBiZSByb3V0ZWQgdG8gYSBjaGF0IHN0b3JlKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDaGF0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAnYWdlbnRfc3RhdHVzJzpcbiAgICAgICAgICAvLyBIYW5kbGUgYWdlbnQgc3RhdHVzIHVwZGF0ZXNcbiAgICAgICAgICBjb25zb2xlLmxvZygnQWdlbnQgc3RhdHVzIHVwZGF0ZTonLCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmtub3duIFdlYlNvY2tldCBtZXNzYWdlIHR5cGU6JywgZGF0YS50eXBlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIFdlYlNvY2tldCBtZXNzYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFt1cGRhdGVWaXRhbFNpZ25zLCBhZGRTZW5zb3JSZWFkaW5nLCB1cGRhdGVTZW5zb3JTdGF0dXMsIGFkZEFsZXJ0LCBhZGRIZWFsdGhBbmFseXNpc10pO1xuXG4gIC8vIEhhbmRsZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBvcGVuXG4gIGNvbnN0IGhhbmRsZU9wZW4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBjb25uZWN0ZWQnKTtcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgaXNDb25uZWN0ZWQ6IHRydWUsXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfSkpO1xuICAgIFxuICAgIC8vIFJlc2V0IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBvbiBzdWNjZXNzZnVsIGNvbm5lY3Rpb25cbiAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50ID0gMDtcbiAgICBcbiAgICAvLyBPbmx5IHNob3cgc3VjY2VzcyB0b2FzdCBpZiB3ZSB3ZXJlIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgaWYgKHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPiAwKSB7XG4gICAgICB0b2FzdC5zdWNjZXNzKCdSZWNvbm5lY3RlZCB0byBPcGhpcmEgQUknLCB7XG4gICAgICAgIGR1cmF0aW9uOiAyMDAwLFxuICAgICAgICBpY29uOiAn8J+UlydcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEhhbmRsZSBXZWJTb2NrZXQgZXJyb3JzXG4gIGNvbnN0IGhhbmRsZUVycm9yID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBlcnJvcjonLCBldmVudCk7XG4gICAgXG4gICAgLy8gT25seSB1cGRhdGUgc3RhdGUgaWYgd2UncmUgbm90IGFscmVhZHkgaW4gYW4gZXJyb3Igc3RhdGUgdG8gcHJldmVudCBsb29wc1xuICAgIHNldFN0YXRlKHByZXYgPT4ge1xuICAgICAgaWYgKHByZXYuY29ubmVjdGlvblN0YXR1cyAhPT0gJ2Vycm9yJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgZXJyb3I6ICdXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvcicsXG4gICAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Vycm9yJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICAvLyBIYW5kbGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VcbiAgY29uc3QgaGFuZGxlQ2xvc2UgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IENsb3NlRXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNsb3NlZDonLCBldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xuICAgIFxuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJ1xuICAgIH0pKTtcblxuICAgIC8vIE9ubHkgYXR0ZW1wdCByZWNvbm5lY3Rpb24gaWYgbm90IG1hbnVhbGx5IGNsb3NlZCBhbmQgYXV0by1yZWNvbm5lY3QgaXMgZW5hYmxlZFxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGNoZWNrcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gICAgaWYgKCFpc01hbnVhbGx5Q2xvc2VkUmVmLmN1cnJlbnQgJiYgXG4gICAgICAgIGF1dG9SZWNvbm5lY3QgJiYgXG4gICAgICAgIGVuYWJsZWQgJiYgXG4gICAgICAgIHNlc3Npb25JZCAmJlxuICAgICAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50IDwgbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgIFxuICAgICAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIHRoZSBjbG9zZSB3YXNuJ3QgZHVlIHRvIGFuIGVycm9yIHN0YXRlXG4gICAgICBpZiAoZXZlbnQuY29kZSAhPT0gMTAwNiAmJiBldmVudC5jb2RlICE9PSAxMDAwKSB7XG4gICAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdyZWNvbm5lY3RpbmcnXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCArPSAxO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHJlY29ubmVjdC4uLiAoJHtyZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50fS8ke21heFJlY29ubmVjdEF0dGVtcHRzfSlgKTtcbiAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH0sIHJlY29ubmVjdEludGVydmFsICogcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCk7IC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPj0gbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgbWF4aW11bSBhdHRlbXB0cycsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdlcnJvcidcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFthdXRvUmVjb25uZWN0LCBlbmFibGVkLCBzZXNzaW9uSWQsIG1heFJlY29ubmVjdEF0dGVtcHRzLCByZWNvbm5lY3RJbnRlcnZhbCwgY29ubmVjdF0pO1xuXG4gIC8vIENvbm5lY3QgdG8gV2ViU29ja2V0XG4gIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFzZXNzaW9uSWQpIHJldHVybjtcblxuICAgIC8vIENsb3NlIGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICBpZiAod2Vic29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdjb25uZWN0aW5nJyxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfSkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdzID0gY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbihzZXNzaW9uSWQpO1xuICAgICAgXG4gICAgICB3cy5vbm9wZW4gPSBoYW5kbGVPcGVuO1xuICAgICAgd3Mub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTtcbiAgICAgIHdzLm9uZXJyb3IgPSBoYW5kbGVFcnJvcjtcbiAgICAgIHdzLm9uY2xvc2UgPSBoYW5kbGVDbG9zZTtcbiAgICAgIFxuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQgPSB3cztcbiAgICAgIGlzTWFudWFsbHlDbG9zZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgV2ViU29ja2V0IGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGNvbm5lY3QnLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZXJyb3InXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgc2Vzc2lvbklkLCBoYW5kbGVPcGVuLCBoYW5kbGVNZXNzYWdlLCBoYW5kbGVFcnJvciwgaGFuZGxlQ2xvc2VdKTtcblxuICAvLyBEaXNjb25uZWN0IGZyb20gV2ViU29ja2V0XG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciByZWNvbm5lY3Rpb24gdGltZW91dFxuICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgcmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xvc2UgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICBpZiAod2Vic29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJ1xuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIC8vIFNlbmQgbWVzc2FnZSB0aHJvdWdoIFdlYlNvY2tldFxuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZUNhbGxiYWNrKChtZXNzYWdlOiBhbnkpID0+IHtcbiAgICBpZiAod2Vic29ja2V0UmVmLmN1cnJlbnQgJiYgc3RhdGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50LnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZW5kIFdlYlNvY2tldCBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFtzdGF0ZS5pc0Nvbm5lY3RlZF0pO1xuXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgY29ubmVjdGlvbiBsaWZlY3ljbGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiBzZXNzaW9uSWQpIHtcbiAgICAgIGNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHNlc3Npb25JZCwgY29ubmVjdCwgZGlzY29ubmVjdF0pO1xuXG4gIC8vIENsZWFudXAgdGltZW91dHMgb24gdW5tb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGNvbm5lY3QsXG4gICAgZGlzY29ubmVjdCxcbiAgICBzZW5kTWVzc2FnZSxcbiAgICByZWNvbm5lY3Q6ICgpID0+IHtcbiAgICAgIHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgICAgY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VNZWRpY2FsU3RvcmUiLCJjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uIiwidG9hc3QiLCJ1c2VPcGhpcmFXZWJTb2NrZXQiLCJlbmFibGVkIiwic2Vzc2lvbklkIiwiYXV0b1JlY29ubmVjdCIsInJlY29ubmVjdEludGVydmFsIiwibWF4UmVjb25uZWN0QXR0ZW1wdHMiLCJzdGF0ZSIsInNldFN0YXRlIiwiaXNDb25uZWN0ZWQiLCJjb25uZWN0aW9uU3RhdHVzIiwibGFzdE1lc3NhZ2UiLCJlcnJvciIsIndlYnNvY2tldFJlZiIsInJlY29ubmVjdFRpbWVvdXRSZWYiLCJyZWNvbm5lY3RBdHRlbXB0c1JlZiIsImlzTWFudWFsbHlDbG9zZWRSZWYiLCJ1cGRhdGVWaXRhbFNpZ25zIiwiYWRkU2Vuc29yUmVhZGluZyIsInVwZGF0ZVNlbnNvclN0YXR1cyIsImFkZEFsZXJ0IiwiYWRkSGVhbHRoQW5hbHlzaXMiLCJoYW5kbGVNZXNzYWdlIiwiZXZlbnQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicHJldiIsInR5cGUiLCJjdXJyZW50IiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJzZW5kIiwic3RyaW5naWZ5IiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVhZGluZyIsInN0YXR1cyIsImFsZXJ0VHlwZSIsIm1lc3NhZ2UiLCJkdXJhdGlvbiIsImljb24iLCJjb25zb2xlIiwibG9nIiwiaGFuZGxlT3BlbiIsInN1Y2Nlc3MiLCJoYW5kbGVFcnJvciIsImhhbmRsZUNsb3NlIiwiY29kZSIsInJlYXNvbiIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjb25uZWN0IiwiY2xvc2UiLCJ3cyIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiRXJyb3IiLCJkaXNjb25uZWN0Iiwic2VuZE1lc3NhZ2UiLCJyZWNvbm5lY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts\n"));

/***/ })

});