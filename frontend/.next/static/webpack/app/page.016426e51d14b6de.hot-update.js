"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts":
/*!*****************************************!*\
  !*** ./src/hooks/useOphiraWebSocket.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOphiraWebSocket: function() { return /* binding */ useOphiraWebSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/medicalStore */ \"(app-pages-browser)/./src/stores/medicalStore.ts\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\nfunction useOphiraWebSocket() {\n    let { enabled = true, sessionId, autoReconnect = true, reconnectInterval = 5000, maxReconnectAttempts = 5 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        connectionStatus: \"disconnected\",\n        lastMessage: null,\n        error: null\n    });\n    const websocketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isManuallyClosedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Medical store actions\n    const { updateVitalSigns, addSensorReading, updateSensorStatus, addAlert, addHealthAnalysis } = (0,_stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__.useMedicalStore)();\n    // Handle incoming WebSocket messages\n    const handleMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        try {\n            const data = JSON.parse(event.data);\n            setState((prev)=>({\n                    ...prev,\n                    lastMessage: data\n                }));\n            // Route messages to appropriate store actions\n            switch(data.type){\n                case \"ping\":\n                    // Respond to server ping with pong\n                    if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\n                        websocketRef.current.send(JSON.stringify({\n                            type: \"pong\",\n                            timestamp: new Date().toISOString()\n                        }));\n                    }\n                    break;\n                case \"vital_signs\":\n                    if (data.data) {\n                        updateVitalSigns(data.data);\n                    }\n                    break;\n                case \"sensor_update\":\n                    if (data.data) {\n                        if (data.data.reading) {\n                            addSensorReading(data.data.reading);\n                        }\n                        if (data.data.status) {\n                            updateSensorStatus(data.data.status);\n                        }\n                    }\n                    break;\n                case \"alert\":\n                    if (data.data) {\n                        addAlert(data.data);\n                        // Show toast notification for alerts\n                        const alertType = data.data.type || \"info\";\n                        const message = data.data.message || \"New medical alert\";\n                        if (alertType === \"critical\" || alertType === \"emergency\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 10000,\n                                icon: \"\\uD83D\\uDEA8\"\n                            });\n                        } else if (alertType === \"warning\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 6000,\n                                icon: \"⚠️\"\n                            });\n                        } else {\n                            (0,react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(message, {\n                                duration: 4000,\n                                icon: \"ℹ️\"\n                            });\n                        }\n                    }\n                    break;\n                case \"chat_message\":\n                    // Handle chat messages (could be routed to a chat store)\n                    console.log(\"Chat message received:\", data.data);\n                    break;\n                case \"agent_status\":\n                    // Handle agent status updates\n                    console.log(\"Agent status update:\", data.data);\n                    break;\n                default:\n                    console.log(\"Unknown WebSocket message type:\", data.type);\n            }\n        } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n        }\n    }, [\n        updateVitalSigns,\n        addSensorReading,\n        updateSensorStatus,\n        addAlert,\n        addHealthAnalysis\n    ]);\n    // Handle WebSocket connection open\n    const handleOpen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"WebSocket connected\");\n        setState((prev)=>({\n                ...prev,\n                isConnected: true,\n                connectionStatus: \"connected\",\n                error: null\n            }));\n        // Reset reconnection attempts on successful connection\n        reconnectAttemptsRef.current = 0;\n        react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].success(\"Connected to Ophira AI\", {\n            duration: 3000,\n            icon: \"\\uD83D\\uDD17\"\n        });\n    }, []);\n    // Handle WebSocket errors\n    const handleError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.error(\"WebSocket error:\", event);\n        setState((prev)=>({\n                ...prev,\n                error: \"WebSocket connection error\",\n                connectionStatus: \"error\"\n            }));\n    }, []);\n    // Handle WebSocket connection close\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.log(\"WebSocket closed:\", event.code, event.reason);\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n        // Only attempt reconnection if not manually closed and auto-reconnect is enabled\n        if (!isManuallyClosedRef.current && autoReconnect && enabled && sessionId) {\n            if (reconnectAttemptsRef.current < maxReconnectAttempts) {\n                setState((prev)=>({\n                        ...prev,\n                        connectionStatus: \"reconnecting\"\n                    }));\n                reconnectTimeoutRef.current = setTimeout(()=>{\n                    reconnectAttemptsRef.current += 1;\n                    console.log(\"Attempting to reconnect... (\".concat(reconnectAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \")\"));\n                    connect();\n                }, reconnectInterval);\n            } else {\n                console.error(\"Max reconnection attempts reached\");\n                setState((prev)=>({\n                        ...prev,\n                        error: \"Failed to reconnect after maximum attempts\",\n                        connectionStatus: \"error\"\n                    }));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(\"Connection lost. Please refresh the page.\", {\n                    duration: 10000,\n                    icon: \"❌\"\n                });\n            }\n        }\n    }, [\n        autoReconnect,\n        enabled,\n        sessionId,\n        maxReconnectAttempts,\n        reconnectInterval\n    ]);\n    // Connect to WebSocket\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!enabled || !sessionId) return;\n        // Close existing connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n        }\n        setState((prev)=>({\n                ...prev,\n                connectionStatus: \"connecting\",\n                error: null\n            }));\n        try {\n            const ws = (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createWebSocketConnection)(sessionId);\n            ws.onopen = handleOpen;\n            ws.onmessage = handleMessage;\n            ws.onerror = handleError;\n            ws.onclose = handleClose;\n            websocketRef.current = ws;\n            isManuallyClosedRef.current = false;\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    error: error instanceof Error ? error.message : \"Failed to connect\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        enabled,\n        sessionId,\n        handleOpen,\n        handleMessage,\n        handleError,\n        handleClose\n    ]);\n    // Disconnect from WebSocket\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        isManuallyClosedRef.current = true;\n        // Clear reconnection timeout\n        if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n            reconnectTimeoutRef.current = null;\n        }\n        // Close WebSocket connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n    }, []);\n    // Send message through WebSocket\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        if (websocketRef.current && state.isConnected) {\n            try {\n                websocketRef.current.send(JSON.stringify(message));\n                return true;\n            } catch (error) {\n                console.error(\"Failed to send WebSocket message:\", error);\n                return false;\n            }\n        }\n        return false;\n    }, [\n        state.isConnected\n    ]);\n    // Effect to handle connection lifecycle\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (enabled && sessionId) {\n            connect();\n        } else {\n            disconnect();\n        }\n        // Cleanup on unmount\n        return ()=>{\n            disconnect();\n        };\n    }, [\n        enabled,\n        sessionId,\n        connect,\n        disconnect\n    ]);\n    // Cleanup timeouts on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n            }\n        };\n    }, []);\n    return {\n        ...state,\n        connect,\n        disconnect,\n        sendMessage,\n        reconnect: ()=>{\n            reconnectAttemptsRef.current = 0;\n            connect();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBRVQ7QUFDRjtBQUNsQjtBQWlCN0IsU0FBU087UUFBbUIsRUFDakNDLFVBQVUsSUFBSSxFQUNkQyxTQUFTLEVBQ1RDLGdCQUFnQixJQUFJLEVBQ3BCQyxvQkFBb0IsSUFBSSxFQUN4QkMsdUJBQXVCLENBQUMsRUFDRSxHQU5PLGlFQU1KLENBQUM7SUFDOUIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFpQjtRQUNqRGEsYUFBYTtRQUNiQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsZUFBZWxCLDZDQUFNQSxDQUFtQjtJQUM5QyxNQUFNbUIsc0JBQXNCbkIsNkNBQU1BLENBQXdCO0lBQzFELE1BQU1vQix1QkFBdUJwQiw2Q0FBTUEsQ0FBQztJQUNwQyxNQUFNcUIsc0JBQXNCckIsNkNBQU1BLENBQUM7SUFFbkMsd0JBQXdCO0lBQ3hCLE1BQU0sRUFDSnNCLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxrQkFBa0IsRUFDbEJDLFFBQVEsRUFDUkMsaUJBQWlCLEVBQ2xCLEdBQUd2QixxRUFBZUE7SUFFbkIscUNBQXFDO0lBQ3JDLE1BQU13QixnQkFBZ0J6QixrREFBV0EsQ0FBQyxDQUFDMEI7UUFDakMsSUFBSTtZQUNGLE1BQU1DLE9BQXVCQyxLQUFLQyxLQUFLLENBQUNILE1BQU1DLElBQUk7WUFFbERoQixTQUFTbUIsQ0FBQUEsT0FBUztvQkFDaEIsR0FBR0EsSUFBSTtvQkFDUGhCLGFBQWFhO2dCQUNmO1lBRUEsOENBQThDO1lBQzlDLE9BQVFBLEtBQUtJLElBQUk7Z0JBQ2YsS0FBSztvQkFDSCxtQ0FBbUM7b0JBQ25DLElBQUlmLGFBQWFnQixPQUFPLElBQUloQixhQUFhZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTt3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RUFBRSxPQUFPN0IsT0FBTztnQkFDZGdDLFFBQVFoQyxLQUFLLENBQUMscUNBQXFDQTtnQkFDbkQsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1QsR0FBRztRQUFDTCxNQUFNRSxXQUFXO0tBQUM7SUFFdEIsd0NBQXdDO0lBQ3hDZixnREFBU0EsQ0FBQztRQUNSLElBQUlRLFdBQVdDLFdBQVc7WUFDeEJrRDtRQUNGLE9BQU87WUFDTFE7UUFDRjtRQUVBLHFCQUFxQjtRQUNyQixPQUFPO1lBQ0xBO1FBQ0Y7SUFDRixHQUFHO1FBQUMzRDtRQUFTQztRQUFXa0Q7UUFBU1E7S0FBVztJQUU1Qyw4QkFBOEI7SUFDOUJuRSxnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTCxJQUFJb0Isb0JBQW9CZSxPQUFPLEVBQUU7Z0JBQy9CaUMsYUFBYWhELG9CQUFvQmUsT0FBTztZQUMxQztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMLEdBQUd0QixLQUFLO1FBQ1I4QztRQUNBUTtRQUNBRTtRQUNBQyxXQUFXO1lBQ1RqRCxxQkFBcUJjLE9BQU8sR0FBRztZQUMvQndCO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHM/NGJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgV2ViU29ja2V0RXZlbnQgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IHVzZU1lZGljYWxTdG9yZSB9IGZyb20gJ0Avc3RvcmVzL21lZGljYWxTdG9yZSc7XG5pbXBvcnQgeyBjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uIH0gZnJvbSAnQC9saWIvYXBpJztcbmltcG9ydCB0b2FzdCBmcm9tICdyZWFjdC1ob3QtdG9hc3QnO1xuXG5pbnRlcmZhY2UgVXNlT3BoaXJhV2ViU29ja2V0T3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG4gIGF1dG9SZWNvbm5lY3Q/OiBib29sZWFuO1xuICByZWNvbm5lY3RJbnRlcnZhbD86IG51bWJlcjtcbiAgbWF4UmVjb25uZWN0QXR0ZW1wdHM/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBXZWJTb2NrZXRTdGF0ZSB7XG4gIGlzQ29ubmVjdGVkOiBib29sZWFuO1xuICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGluZycgfCAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnIHwgJ2Vycm9yJyB8ICdyZWNvbm5lY3RpbmcnO1xuICBsYXN0TWVzc2FnZTogV2ViU29ja2V0RXZlbnQgfCBudWxsO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9waGlyYVdlYlNvY2tldCh7XG4gIGVuYWJsZWQgPSB0cnVlLFxuICBzZXNzaW9uSWQsXG4gIGF1dG9SZWNvbm5lY3QgPSB0cnVlLFxuICByZWNvbm5lY3RJbnRlcnZhbCA9IDUwMDAsXG4gIG1heFJlY29ubmVjdEF0dGVtcHRzID0gNVxufTogVXNlT3BoaXJhV2ViU29ja2V0T3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8V2ViU29ja2V0U3RhdGU+KHtcbiAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgY29ubmVjdGlvblN0YXR1czogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgbGFzdE1lc3NhZ2U6IG51bGwsXG4gICAgZXJyb3I6IG51bGxcbiAgfSk7XG5cbiAgY29uc3Qgd2Vic29ja2V0UmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZWNvbm5lY3RUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlY29ubmVjdEF0dGVtcHRzUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBpc01hbnVhbGx5Q2xvc2VkUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICAvLyBNZWRpY2FsIHN0b3JlIGFjdGlvbnNcbiAgY29uc3Qge1xuICAgIHVwZGF0ZVZpdGFsU2lnbnMsXG4gICAgYWRkU2Vuc29yUmVhZGluZyxcbiAgICB1cGRhdGVTZW5zb3JTdGF0dXMsXG4gICAgYWRkQWxlcnQsXG4gICAgYWRkSGVhbHRoQW5hbHlzaXNcbiAgfSA9IHVzZU1lZGljYWxTdG9yZSgpO1xuXG4gIC8vIEhhbmRsZSBpbmNvbWluZyBXZWJTb2NrZXQgbWVzc2FnZXNcbiAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IHVzZUNhbGxiYWNrKChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGE6IFdlYlNvY2tldEV2ZW50ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBsYXN0TWVzc2FnZTogZGF0YVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBSb3V0ZSBtZXNzYWdlcyB0byBhcHByb3ByaWF0ZSBzdG9yZSBhY3Rpb25zXG4gICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICBjYXNlICdwaW5nJzpcbiAgICAgICAgICAvLyBSZXNwb25kIHRvIHNlcnZlciBwaW5nIHdpdGggcG9uZ1xuICAgICAgICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCAmJiB3ZWJzb2NrZXRSZWYuY3VycmVudC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHR5cGU6ICdwb25nJyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ3ZpdGFsX3NpZ25zJzpcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICB1cGRhdGVWaXRhbFNpZ25zKGRhdGEuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdzZW5zb3JfdXBkYXRlJzpcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhLnJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgYWRkU2Vuc29yUmVhZGluZyhkYXRhLmRhdGEucmVhZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICB1cGRhdGVTZW5zb3JTdGF0dXMoZGF0YS5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdhbGVydCc6XG4gICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgYWRkQWxlcnQoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyB0b2FzdCBub3RpZmljYXRpb24gZm9yIGFsZXJ0c1xuICAgICAgICAgICAgY29uc3QgYWxlcnRUeXBlID0gZGF0YS5kYXRhLnR5cGUgfHwgJ2luZm8nO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRhdGEuZGF0YS5tZXNzYWdlIHx8ICdOZXcgbWVkaWNhbCBhbGVydCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhbGVydFR5cGUgPT09ICdjcml0aWNhbCcgfHwgYWxlcnRUeXBlID09PSAnZW1lcmdlbmN5Jykge1xuICAgICAgICAgICAgICB0b2FzdC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDAwLFxuICAgICAgICAgICAgICAgIGljb246ICfwn5qoJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxlcnRUeXBlID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgICAgdG9hc3QuZXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA2MDAwLFxuICAgICAgICAgICAgICAgIGljb246ICfimqDvuI8nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9hc3QobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA0MDAwLFxuICAgICAgICAgICAgICAgIGljb246ICfihLnvuI8nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAnY2hhdF9tZXNzYWdlJzpcbiAgICAgICAgICAvLyBIYW5kbGUgY2hhdCBtZXNzYWdlcyAoY291bGQgYmUgcm91dGVkIHRvIGEgY2hhdCBzdG9yZSlcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2hhdCBtZXNzYWdlIHJlY2VpdmVkOicsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ2FnZW50X3N0YXR1cyc6XG4gICAgICAgICAgLy8gSGFuZGxlIGFnZW50IHN0YXR1cyB1cGRhdGVzXG4gICAgICAgICAgY29uc29sZS5sb2coJ0FnZW50IHN0YXR1cyB1cGRhdGU6JywgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biBXZWJTb2NrZXQgbWVzc2FnZSB0eXBlOicsIGRhdGEudHlwZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbdXBkYXRlVml0YWxTaWducywgYWRkU2Vuc29yUmVhZGluZywgdXBkYXRlU2Vuc29yU3RhdHVzLCBhZGRBbGVydCwgYWRkSGVhbHRoQW5hbHlzaXNdKTtcblxuICAvLyBIYW5kbGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gb3BlblxuICBjb25zdCBoYW5kbGVPcGVuID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pKTtcbiAgICBcbiAgICAvLyBSZXNldCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgXG4gICAgdG9hc3Quc3VjY2VzcygnQ29ubmVjdGVkIHRvIE9waGlyYSBBSScsIHtcbiAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgaWNvbjogJ/CflJcnXG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICAvLyBIYW5kbGUgV2ViU29ja2V0IGVycm9yc1xuICBjb25zdCBoYW5kbGVFcnJvciA9IHVzZUNhbGxiYWNrKChldmVudDogRXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXZlbnQpO1xuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBlcnJvcjogJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yJyxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdlcnJvcidcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICAvLyBIYW5kbGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VcbiAgY29uc3QgaGFuZGxlQ2xvc2UgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IENsb3NlRXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNsb3NlZDonLCBldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xuICAgIFxuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJ1xuICAgIH0pKTtcblxuICAgIC8vIE9ubHkgYXR0ZW1wdCByZWNvbm5lY3Rpb24gaWYgbm90IG1hbnVhbGx5IGNsb3NlZCBhbmQgYXV0by1yZWNvbm5lY3QgaXMgZW5hYmxlZFxuICAgIGlmICghaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ICYmIGF1dG9SZWNvbm5lY3QgJiYgZW5hYmxlZCAmJiBzZXNzaW9uSWQpIHtcbiAgICAgIGlmIChyZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50IDwgbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ3JlY29ubmVjdGluZydcbiAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgcmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCArPSAxO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHJlY29ubmVjdC4uLiAoJHtyZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50fS8ke21heFJlY29ubmVjdEF0dGVtcHRzfSlgKTtcbiAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH0sIHJlY29ubmVjdEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xuICAgICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgbWF4aW11bSBhdHRlbXB0cycsXG4gICAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Vycm9yJ1xuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICB0b2FzdC5lcnJvcignQ29ubmVjdGlvbiBsb3N0LiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZS4nLCB7XG4gICAgICAgICAgZHVyYXRpb246IDEwMDAwLFxuICAgICAgICAgIGljb246ICfinYwnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2F1dG9SZWNvbm5lY3QsIGVuYWJsZWQsIHNlc3Npb25JZCwgbWF4UmVjb25uZWN0QXR0ZW1wdHMsIHJlY29ubmVjdEludGVydmFsXSk7XG5cbiAgLy8gQ29ubmVjdCB0byBXZWJTb2NrZXRcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXNlc3Npb25JZCkgcmV0dXJuO1xuXG4gICAgLy8gQ2xvc2UgZXhpc3RpbmcgY29ubmVjdGlvblxuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RpbmcnLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgd3MgPSBjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uKHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIHdzLm9ub3BlbiA9IGhhbmRsZU9wZW47XG4gICAgICB3cy5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuICAgICAgd3Mub25lcnJvciA9IGhhbmRsZUVycm9yO1xuICAgICAgd3Mub25jbG9zZSA9IGhhbmRsZUNsb3NlO1xuICAgICAgXG4gICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudCA9IHdzO1xuICAgICAgaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQgY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gY29ubmVjdCcsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdlcnJvcidcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBzZXNzaW9uSWQsIGhhbmRsZU9wZW4sIGhhbmRsZU1lc3NhZ2UsIGhhbmRsZUVycm9yLCBoYW5kbGVDbG9zZV0pO1xuXG4gIC8vIERpc2Nvbm5lY3QgZnJvbSBXZWJTb2NrZXRcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpc01hbnVhbGx5Q2xvc2VkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIFxuICAgIC8vIENsZWFyIHJlY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbG9zZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgLy8gU2VuZCBtZXNzYWdlIHRocm91Z2ggV2ViU29ja2V0XG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCAmJiBzdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlbmQgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW3N0YXRlLmlzQ29ubmVjdGVkXSk7XG5cbiAgLy8gRWZmZWN0IHRvIGhhbmRsZSBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmIHNlc3Npb25JZCkge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgc2Vzc2lvbklkLCBjb25uZWN0LCBkaXNjb25uZWN0XSk7XG5cbiAgLy8gQ2xlYW51cCB0aW1lb3V0cyBvbiB1bm1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgY29ubmVjdCxcbiAgICBkaXNjb25uZWN0LFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIHJlY29ubmVjdDogKCkgPT4ge1xuICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lZGljYWxTdG9yZSIsImNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24iLCJ0b2FzdCIsInVzZU9waGlyYVdlYlNvY2tldCIsImVuYWJsZWQiLCJzZXNzaW9uSWQiLCJhdXRvUmVjb25uZWN0IiwicmVjb25uZWN0SW50ZXJ2YWwiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsInN0YXRlIiwic2V0U3RhdGUiLCJpc0Nvbm5lY3RlZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJsYXN0TWVzc2FnZSIsImVycm9yIiwid2Vic29ja2V0UmVmIiwicmVjb25uZWN0VGltZW91dFJlZiIsInJlY29ubmVjdEF0dGVtcHRzUmVmIiwiaXNNYW51YWxseUNsb3NlZFJlZiIsInVwZGF0ZVZpdGFsU2lnbnMiLCJhZGRTZW5zb3JSZWFkaW5nIiwidXBkYXRlU2Vuc29yU3RhdHVzIiwiYWRkQWxlcnQiLCJhZGRIZWFsdGhBbmFseXNpcyIsImhhbmRsZU1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJwcmV2IiwidHlwZSIsImN1cnJlbnQiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsInNlbmQiLCJzdHJpbmdpZnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZWFkaW5nIiwic3RhdHVzIiwiYWxlcnRUeXBlIiwibWVzc2FnZSIsImR1cmF0aW9uIiwiaWNvbiIsImNvbnNvbGUiLCJsb2ciLCJoYW5kbGVPcGVuIiwic3VjY2VzcyIsImhhbmRsZUVycm9yIiwiaGFuZGxlQ2xvc2UiLCJjb2RlIiwicmVhc29uIiwic2V0VGltZW91dCIsImNvbm5lY3QiLCJjbG9zZSIsIndzIiwib25vcGVuIiwib25tZXNzYWdlIiwib25lcnJvciIsIm9uY2xvc2UiLCJFcnJvciIsImRpc2Nvbm5lY3QiLCJjbGVhclRpbWVvdXQiLCJzZW5kTWVzc2FnZSIsInJlY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts\n"));

/***/ })

});