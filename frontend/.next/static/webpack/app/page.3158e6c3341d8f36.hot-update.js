"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts":
/*!*****************************************!*\
  !*** ./src/hooks/useOphiraWebSocket.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOphiraWebSocket: function() { return /* binding */ useOphiraWebSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/medicalStore */ \"(app-pages-browser)/./src/stores/medicalStore.ts\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\nfunction useOphiraWebSocket() {\n    let { enabled = true, sessionId, autoReconnect = true, reconnectInterval = 5000, maxReconnectAttempts = 5 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        connectionStatus: \"disconnected\",\n        lastMessage: null,\n        error: null\n    });\n    const websocketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isManuallyClosedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Medical store actions\n    const { updateVitalSigns, addSensorReading, updateSensorStatus, addAlert, addHealthAnalysis } = (0,_stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__.useMedicalStore)();\n    // Handle incoming WebSocket messages\n    const handleMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        try {\n            const data = JSON.parse(event.data);\n            setState((prev)=>({\n                    ...prev,\n                    lastMessage: data\n                }));\n            // Route messages to appropriate store actions\n            switch(data.type){\n                case \"ping\":\n                    // Respond to server ping with pong\n                    if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\n                        websocketRef.current.send(JSON.stringify({\n                            type: \"pong\",\n                            timestamp: new Date().toISOString()\n                        }));\n                    }\n                    break;\n                case \"vital_signs\":\n                    if (data.data) {\n                        updateVitalSigns(data.data);\n                    }\n                    break;\n                case \"sensor_update\":\n                    if (data.data) {\n                        if (data.data.reading) {\n                            addSensorReading(data.data.reading);\n                        }\n                        if (data.data.status) {\n                            updateSensorStatus(data.data.status);\n                        }\n                    }\n                    break;\n                case \"alert\":\n                    if (data.data) {\n                        addAlert(data.data);\n                        // Show toast notification for alerts\n                        const alertType = data.data.type || \"info\";\n                        const message = data.data.message || \"New medical alert\";\n                        if (alertType === \"critical\" || alertType === \"emergency\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 10000,\n                                icon: \"\\uD83D\\uDEA8\"\n                            });\n                        } else if (alertType === \"warning\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 6000,\n                                icon: \"⚠️\"\n                            });\n                        } else {\n                            (0,react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(message, {\n                                duration: 4000,\n                                icon: \"ℹ️\"\n                            });\n                        }\n                    }\n                    break;\n                case \"chat_message\":\n                    // Handle chat messages (could be routed to a chat store)\n                    console.log(\"Chat message received:\", data.data);\n                    break;\n                case \"agent_status\":\n                    // Handle agent status updates\n                    console.log(\"Agent status update:\", data.data);\n                    break;\n                default:\n                    console.log(\"Unknown WebSocket message type:\", data.type);\n            }\n        } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n        }\n    }, [\n        updateVitalSigns,\n        addSensorReading,\n        updateSensorStatus,\n        addAlert,\n        addHealthAnalysis\n    ]);\n    // Handle WebSocket connection open\n    const handleOpen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"WebSocket connected\");\n        setState((prev)=>({\n                ...prev,\n                isConnected: true,\n                connectionStatus: \"connected\",\n                error: null\n            }));\n        // Reset reconnection attempts on successful connection\n        reconnectAttemptsRef.current = 0;\n        // Only show success toast if we were previously disconnected\n        if (reconnectAttemptsRef.current > 0) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].success(\"Reconnected to Ophira AI\", {\n                duration: 2000,\n                icon: \"\\uD83D\\uDD17\"\n            });\n        }\n    }, []);\n    // Handle WebSocket errors\n    const handleError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.error(\"WebSocket error:\", event);\n        // Only update state if we're not already in an error state to prevent loops\n        setState((prev)=>{\n            if (prev.connectionStatus !== \"error\") {\n                return {\n                    ...prev,\n                    error: \"WebSocket connection error\",\n                    connectionStatus: \"error\"\n                };\n            }\n            return prev;\n        });\n    }, []);\n    // Handle WebSocket connection close\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.log(\"WebSocket closed:\", event.code, event.reason);\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n        // Only attempt reconnection if not manually closed and auto-reconnect is enabled\n        // Add additional checks to prevent infinite loops\n        if (!isManuallyClosedRef.current && autoReconnect && enabled && sessionId && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            // Only try to reconnect if the close wasn't due to an error state\n            if (event.code !== 1006 && event.code !== 1000) {\n                setState((prev)=>({\n                        ...prev,\n                        connectionStatus: \"reconnecting\"\n                    }));\n                // Clear any existing timeout\n                if (reconnectTimeoutRef.current) {\n                    clearTimeout(reconnectTimeoutRef.current);\n                }\n                reconnectTimeoutRef.current = setTimeout(()=>{\n                    reconnectAttemptsRef.current += 1;\n                    console.log(\"Attempting to reconnect... (\".concat(reconnectAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \")\"));\n                    // Inline reconnection logic to avoid circular dependency\n                    if (enabled && sessionId) {\n                        if (websocketRef.current) {\n                            websocketRef.current.close();\n                        }\n                        setState((prev)=>({\n                                ...prev,\n                                connectionStatus: \"connecting\",\n                                error: null\n                            }));\n                        try {\n                            const ws = (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createWebSocketConnection)(sessionId);\n                            ws.onopen = handleOpen;\n                            ws.onmessage = handleMessage;\n                            ws.onerror = handleError;\n                            ws.onclose = handleClose;\n                            websocketRef.current = ws;\n                            isManuallyClosedRef.current = false;\n                        } catch (error) {\n                            console.error(\"Failed to create WebSocket connection:\", error);\n                            setState((prev)=>({\n                                    ...prev,\n                                    error: error instanceof Error ? error.message : \"Failed to connect\",\n                                    connectionStatus: \"error\"\n                                }));\n                        }\n                    }\n                }, reconnectInterval * reconnectAttemptsRef.current); // Exponential backoff\n            }\n        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            console.error(\"Max reconnection attempts reached\");\n            setState((prev)=>({\n                    ...prev,\n                    error: \"Failed to reconnect after maximum attempts\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        autoReconnect,\n        enabled,\n        sessionId,\n        maxReconnectAttempts,\n        reconnectInterval,\n        handleOpen,\n        handleMessage,\n        handleError\n    ]);\n    // Connect to WebSocket\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!enabled || !sessionId) return;\n        // Close existing connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n        }\n        setState((prev)=>({\n                ...prev,\n                connectionStatus: \"connecting\",\n                error: null\n            }));\n        try {\n            const ws = (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createWebSocketConnection)(sessionId);\n            ws.onopen = handleOpen;\n            ws.onmessage = handleMessage;\n            ws.onerror = handleError;\n            ws.onclose = handleClose;\n            websocketRef.current = ws;\n            isManuallyClosedRef.current = false;\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    error: error instanceof Error ? error.message : \"Failed to connect\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        enabled,\n        sessionId,\n        handleOpen,\n        handleMessage,\n        handleError,\n        handleClose\n    ]);\n    // Disconnect from WebSocket\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        isManuallyClosedRef.current = true;\n        // Clear reconnection timeout\n        if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n            reconnectTimeoutRef.current = null;\n        }\n        // Close WebSocket connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n    }, []);\n    // Send message through WebSocket\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        if (websocketRef.current && state.isConnected) {\n            try {\n                websocketRef.current.send(JSON.stringify(message));\n                return true;\n            } catch (error) {\n                console.error(\"Failed to send WebSocket message:\", error);\n                return false;\n            }\n        }\n        return false;\n    }, [\n        state.isConnected\n    ]);\n    // Effect to handle connection lifecycle\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (enabled && sessionId) {\n            connect();\n        } else {\n            disconnect();\n        }\n        // Cleanup on unmount\n        return ()=>{\n            disconnect();\n        };\n    }, [\n        enabled,\n        sessionId,\n        connect,\n        disconnect\n    ]);\n    // Cleanup timeouts on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n            }\n        };\n    }, []);\n    return {\n        ...state,\n        connect,\n        disconnect,\n        sendMessage,\n        reconnect: ()=>{\n            reconnectAttemptsRef.current = 0;\n            connect();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBRVQ7QUFDRjtBQUNsQjtBQWlCN0IsU0FBU087UUFBbUIsRUFDakNDLFVBQVUsSUFBSSxFQUNkQyxTQUFTLEVBQ1RDLGdCQUFnQixJQUFJLEVBQ3BCQyxvQkFBb0IsSUFBSSxFQUN4QkMsdUJBQXVCLENBQUMsRUFDRSxHQU5PLGlFQU1KLENBQUM7SUFDOUIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFpQjtRQUNqRGEsYUFBYTtRQUNiQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsZUFBZWxCLDZDQUFNQSxDQUFtQjtJQUM5QyxNQUFNbUIsc0JBQXNCbkIsNkNBQU1BLENBQXdCO0lBQzFELE1BQU1vQix1QkFBdUJwQiw2Q0FBTUEsQ0FBQztJQUNwQyxNQUFNcUIsc0JBQXNCckIsNkNBQU1BLENBQUM7SUFFbkMsd0JBQXdCO0lBQ3hCLE1BQU0sRUFDSnNCLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxrQkFBa0IsRUFDbEJDLFFBQVEsRUFDUkMsaUJBQWlCLEVBQ2xCLEdBQUd2QixxRUFBZUE7SUFFbkIscUNBQXFDO0lBQ3JDLE1BQU13QixnQkFBZ0J6QixrREFBV0EsQ0FBQyxDQUFDMEI7UUFDakMsSUFBSTtZQUNGLE1BQU1DLE9BQXVCQyxLQUFLQyxLQUFLLENBQUNILE1BQU1DLElBQUk7WUFFbERoQixTQUFTbUIsQ0FBQUEsT0FBUztvQkFDaEIsR0FBR0EsSUFBSTtvQkFDUGhCLGFBQWFhO2dCQUNmO1lBRUEsOENBQThDO1lBQzlDLE9BQVFBLEtBQUtJLElBQUk7Z0JBQ2YsS0FBSztvQkFDSCxtQ0FBbUM7b0JBQ25DLElBQUlmLGFBQWFnQixPQUFPLElBQUloQixhQUFhZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTt3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QUMscUNBQXFDQTtnQkFDbkQsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1QsR0FBRztRQUFDTCxNQUFNRSxXQUFXO0tBQUM7SUFFdEIsd0NBQXdDO0lBQ3hDZixnREFBU0EsQ0FBQztRQUNSLElBQUlRLFdBQVdDLFdBQVc7WUFDeEIwRDtRQUNGLE9BQU87WUFDTEM7UUFDRjtRQUVBLHFCQUFxQjtRQUNyQixPQUFPO1lBQ0xBO1FBQ0Y7SUFDRixHQUFHO1FBQUM1RDtRQUFTQztRQUFXMEQ7UUFBU0M7S0FBVztJQUU1Qyw4QkFBOEI7SUFDOUJwRSxnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTCxJQUFJb0Isb0JBQW9CZSxPQUFPLEVBQUU7Z0JBQy9CdUIsYUFBYXRDLG9CQUFvQmUsT0FBTztZQUMxQztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMLEdBQUd0QixLQUFLO1FBQ1JzRDtRQUNBQztRQUNBQztRQUNBQyxXQUFXO1lBQ1RqRCxxQkFBcUJjLE9BQU8sR0FBRztZQUMvQmdDO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHM/NGJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgV2ViU29ja2V0RXZlbnQgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IHVzZU1lZGljYWxTdG9yZSB9IGZyb20gJ0Avc3RvcmVzL21lZGljYWxTdG9yZSc7XG5pbXBvcnQgeyBjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uIH0gZnJvbSAnQC9saWIvYXBpJztcbmltcG9ydCB0b2FzdCBmcm9tICdyZWFjdC1ob3QtdG9hc3QnO1xuXG5pbnRlcmZhY2UgVXNlT3BoaXJhV2ViU29ja2V0T3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG4gIGF1dG9SZWNvbm5lY3Q/OiBib29sZWFuO1xuICByZWNvbm5lY3RJbnRlcnZhbD86IG51bWJlcjtcbiAgbWF4UmVjb25uZWN0QXR0ZW1wdHM/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBXZWJTb2NrZXRTdGF0ZSB7XG4gIGlzQ29ubmVjdGVkOiBib29sZWFuO1xuICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGluZycgfCAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnIHwgJ2Vycm9yJyB8ICdyZWNvbm5lY3RpbmcnO1xuICBsYXN0TWVzc2FnZTogV2ViU29ja2V0RXZlbnQgfCBudWxsO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9waGlyYVdlYlNvY2tldCh7XG4gIGVuYWJsZWQgPSB0cnVlLFxuICBzZXNzaW9uSWQsXG4gIGF1dG9SZWNvbm5lY3QgPSB0cnVlLFxuICByZWNvbm5lY3RJbnRlcnZhbCA9IDUwMDAsXG4gIG1heFJlY29ubmVjdEF0dGVtcHRzID0gNVxufTogVXNlT3BoaXJhV2ViU29ja2V0T3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8V2ViU29ja2V0U3RhdGU+KHtcbiAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgY29ubmVjdGlvblN0YXR1czogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgbGFzdE1lc3NhZ2U6IG51bGwsXG4gICAgZXJyb3I6IG51bGxcbiAgfSk7XG5cbiAgY29uc3Qgd2Vic29ja2V0UmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZWNvbm5lY3RUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlY29ubmVjdEF0dGVtcHRzUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBpc01hbnVhbGx5Q2xvc2VkUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICAvLyBNZWRpY2FsIHN0b3JlIGFjdGlvbnNcbiAgY29uc3Qge1xuICAgIHVwZGF0ZVZpdGFsU2lnbnMsXG4gICAgYWRkU2Vuc29yUmVhZGluZyxcbiAgICB1cGRhdGVTZW5zb3JTdGF0dXMsXG4gICAgYWRkQWxlcnQsXG4gICAgYWRkSGVhbHRoQW5hbHlzaXNcbiAgfSA9IHVzZU1lZGljYWxTdG9yZSgpO1xuXG4gIC8vIEhhbmRsZSBpbmNvbWluZyBXZWJTb2NrZXQgbWVzc2FnZXNcbiAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IHVzZUNhbGxiYWNrKChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGE6IFdlYlNvY2tldEV2ZW50ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBsYXN0TWVzc2FnZTogZGF0YVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBSb3V0ZSBtZXNzYWdlcyB0byBhcHByb3ByaWF0ZSBzdG9yZSBhY3Rpb25zXG4gICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICBjYXNlICdwaW5nJzpcbiAgICAgICAgICAvLyBSZXNwb25kIHRvIHNlcnZlciBwaW5nIHdpdGggcG9uZ1xuICAgICAgICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCAmJiB3ZWJzb2NrZXRSZWYuY3VycmVudC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHR5cGU6ICdwb25nJyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ3ZpdGFsX3NpZ25zJzpcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICB1cGRhdGVWaXRhbFNpZ25zKGRhdGEuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdzZW5zb3JfdXBkYXRlJzpcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhLnJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgYWRkU2Vuc29yUmVhZGluZyhkYXRhLmRhdGEucmVhZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICB1cGRhdGVTZW5zb3JTdGF0dXMoZGF0YS5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdhbGVydCc6XG4gICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgYWRkQWxlcnQoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyB0b2FzdCBub3RpZmljYXRpb24gZm9yIGFsZXJ0c1xuICAgICAgICAgICAgY29uc3QgYWxlcnRUeXBlID0gZGF0YS5kYXRhLnR5cGUgfHwgJ2luZm8nO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRhdGEuZGF0YS5tZXNzYWdlIHx8ICdOZXcgbWVkaWNhbCBhbGVydCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhbGVydFR5cGUgPT09ICdjcml0aWNhbCcgfHwgYWxlcnRUeXBlID09PSAnZW1lcmdlbmN5Jykge1xuICAgICAgICAgICAgICB0b2FzdC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDAwLFxuICAgICAgICAgICAgICAgIGljb246ICfwn5qoJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxlcnRUeXBlID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgICAgdG9hc3QuZXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA2MDAwLFxuICAgICAgICAgICAgICAgIGljb246ICfimqDvuI8nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9hc3QobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA0MDAwLFxuICAgICAgICAgICAgICAgIGljb246ICfihLnvuI8nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAnY2hhdF9tZXNzYWdlJzpcbiAgICAgICAgICAvLyBIYW5kbGUgY2hhdCBtZXNzYWdlcyAoY291bGQgYmUgcm91dGVkIHRvIGEgY2hhdCBzdG9yZSlcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2hhdCBtZXNzYWdlIHJlY2VpdmVkOicsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ2FnZW50X3N0YXR1cyc6XG4gICAgICAgICAgLy8gSGFuZGxlIGFnZW50IHN0YXR1cyB1cGRhdGVzXG4gICAgICAgICAgY29uc29sZS5sb2coJ0FnZW50IHN0YXR1cyB1cGRhdGU6JywgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biBXZWJTb2NrZXQgbWVzc2FnZSB0eXBlOicsIGRhdGEudHlwZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbdXBkYXRlVml0YWxTaWducywgYWRkU2Vuc29yUmVhZGluZywgdXBkYXRlU2Vuc29yU3RhdHVzLCBhZGRBbGVydCwgYWRkSGVhbHRoQW5hbHlzaXNdKTtcblxuICAvLyBIYW5kbGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gb3BlblxuICBjb25zdCBoYW5kbGVPcGVuID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pKTtcbiAgICBcbiAgICAvLyBSZXNldCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgXG4gICAgLy8gT25seSBzaG93IHN1Y2Nlc3MgdG9hc3QgaWYgd2Ugd2VyZSBwcmV2aW91c2x5IGRpc2Nvbm5lY3RlZFxuICAgIGlmIChyZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50ID4gMCkge1xuICAgICAgdG9hc3Quc3VjY2VzcygnUmVjb25uZWN0ZWQgdG8gT3BoaXJhIEFJJywge1xuICAgICAgICBkdXJhdGlvbjogMjAwMCxcbiAgICAgICAgaWNvbjogJ/CflJcnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBIYW5kbGUgV2ViU29ja2V0IGVycm9yc1xuICBjb25zdCBoYW5kbGVFcnJvciA9IHVzZUNhbGxiYWNrKChldmVudDogRXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXZlbnQpO1xuICAgIFxuICAgIC8vIE9ubHkgdXBkYXRlIHN0YXRlIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IGluIGFuIGVycm9yIHN0YXRlIHRvIHByZXZlbnQgbG9vcHNcbiAgICBzZXRTdGF0ZShwcmV2ID0+IHtcbiAgICAgIGlmIChwcmV2LmNvbm5lY3Rpb25TdGF0dXMgIT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIGVycm9yOiAnV2ViU29ja2V0IGNvbm5lY3Rpb24gZXJyb3InLFxuICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdlcnJvcidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgLy8gSGFuZGxlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlXG4gIGNvbnN0IGhhbmRsZUNsb3NlID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBjbG9zZWQ6JywgZXZlbnQuY29kZSwgZXZlbnQucmVhc29uKTtcbiAgICBcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Rpc2Nvbm5lY3RlZCdcbiAgICB9KSk7XG5cbiAgICAvLyBPbmx5IGF0dGVtcHQgcmVjb25uZWN0aW9uIGlmIG5vdCBtYW51YWxseSBjbG9zZWQgYW5kIGF1dG8tcmVjb25uZWN0IGlzIGVuYWJsZWRcbiAgICAvLyBBZGQgYWRkaXRpb25hbCBjaGVja3MgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgIGlmICghaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ICYmIFxuICAgICAgICBhdXRvUmVjb25uZWN0ICYmIFxuICAgICAgICBlbmFibGVkICYmIFxuICAgICAgICBzZXNzaW9uSWQgJiZcbiAgICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA8IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICBcbiAgICAgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiB0aGUgY2xvc2Ugd2Fzbid0IGR1ZSB0byBhbiBlcnJvciBzdGF0ZVxuICAgICAgaWYgKGV2ZW50LmNvZGUgIT09IDEwMDYgJiYgZXZlbnQuY29kZSAhPT0gMTAwMCkge1xuICAgICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAncmVjb25uZWN0aW5nJ1xuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dFxuICAgICAgICBpZiAocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgKz0gMTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byByZWNvbm5lY3QuLi4gKCR7cmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudH0vJHttYXhSZWNvbm5lY3RBdHRlbXB0c30pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5saW5lIHJlY29ubmVjdGlvbiBsb2dpYyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICAgICAgaWYgKGVuYWJsZWQgJiYgc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBpZiAod2Vic29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGluZycsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdzID0gY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbihzZXNzaW9uSWQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgd3Mub25vcGVuID0gaGFuZGxlT3BlbjtcbiAgICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTtcbiAgICAgICAgICAgICAgd3Mub25lcnJvciA9IGhhbmRsZUVycm9yO1xuICAgICAgICAgICAgICB3cy5vbmNsb3NlID0gaGFuZGxlQ2xvc2U7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudCA9IHdzO1xuICAgICAgICAgICAgICBpc01hbnVhbGx5Q2xvc2VkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBjb25uZWN0JyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJlY29ubmVjdEludGVydmFsICogcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCk7IC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPj0gbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgbWF4aW11bSBhdHRlbXB0cycsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdlcnJvcidcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFthdXRvUmVjb25uZWN0LCBlbmFibGVkLCBzZXNzaW9uSWQsIG1heFJlY29ubmVjdEF0dGVtcHRzLCByZWNvbm5lY3RJbnRlcnZhbCwgaGFuZGxlT3BlbiwgaGFuZGxlTWVzc2FnZSwgaGFuZGxlRXJyb3JdKTtcblxuICAvLyBDb25uZWN0IHRvIFdlYlNvY2tldFxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCB8fCAhc2Vzc2lvbklkKSByZXR1cm47XG5cbiAgICAvLyBDbG9zZSBleGlzdGluZyBjb25uZWN0aW9uXG4gICAgaWYgKHdlYnNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGluZycsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB3cyA9IGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24oc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgd3Mub25vcGVuID0gaGFuZGxlT3BlbjtcbiAgICAgIHdzLm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7XG4gICAgICB3cy5vbmVycm9yID0gaGFuZGxlRXJyb3I7XG4gICAgICB3cy5vbmNsb3NlID0gaGFuZGxlQ2xvc2U7XG4gICAgICBcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50ID0gd3M7XG4gICAgICBpc01hbnVhbGx5Q2xvc2VkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBjb25uZWN0JyxcbiAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Vycm9yJ1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHNlc3Npb25JZCwgaGFuZGxlT3BlbiwgaGFuZGxlTWVzc2FnZSwgaGFuZGxlRXJyb3IsIGhhbmRsZUNsb3NlXSk7XG5cbiAgLy8gRGlzY29ubmVjdCBmcm9tIFdlYlNvY2tldFxuICBjb25zdCBkaXNjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlzTWFudWFsbHlDbG9zZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgXG4gICAgLy8gQ2xlYXIgcmVjb25uZWN0aW9uIHRpbWVvdXRcbiAgICBpZiAocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIENsb3NlIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgaWYgKHdlYnNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudC5jbG9zZSgpO1xuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Rpc2Nvbm5lY3RlZCdcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICAvLyBTZW5kIG1lc3NhZ2UgdGhyb3VnaCBXZWJTb2NrZXRcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjaygobWVzc2FnZTogYW55KSA9PiB7XG4gICAgaWYgKHdlYnNvY2tldFJlZi5jdXJyZW50ICYmIHN0YXRlLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudC5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VuZCBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBbc3RhdGUuaXNDb25uZWN0ZWRdKTtcblxuICAvLyBFZmZlY3QgdG8gaGFuZGxlIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVuYWJsZWQgJiYgc2Vzc2lvbklkKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBzZXNzaW9uSWQsIGNvbm5lY3QsIGRpc2Nvbm5lY3RdKTtcblxuICAvLyBDbGVhbnVwIHRpbWVvdXRzIG9uIHVubW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjb25uZWN0LFxuICAgIGRpc2Nvbm5lY3QsXG4gICAgc2VuZE1lc3NhZ2UsXG4gICAgcmVjb25uZWN0OiAoKSA9PiB7XG4gICAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50ID0gMDtcbiAgICAgIGNvbm5lY3QoKTtcbiAgICB9XG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVkaWNhbFN0b3JlIiwiY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbiIsInRvYXN0IiwidXNlT3BoaXJhV2ViU29ja2V0IiwiZW5hYmxlZCIsInNlc3Npb25JZCIsImF1dG9SZWNvbm5lY3QiLCJyZWNvbm5lY3RJbnRlcnZhbCIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiY29ubmVjdGlvblN0YXR1cyIsImxhc3RNZXNzYWdlIiwiZXJyb3IiLCJ3ZWJzb2NrZXRSZWYiLCJyZWNvbm5lY3RUaW1lb3V0UmVmIiwicmVjb25uZWN0QXR0ZW1wdHNSZWYiLCJpc01hbnVhbGx5Q2xvc2VkUmVmIiwidXBkYXRlVml0YWxTaWducyIsImFkZFNlbnNvclJlYWRpbmciLCJ1cGRhdGVTZW5zb3JTdGF0dXMiLCJhZGRBbGVydCIsImFkZEhlYWx0aEFuYWx5c2lzIiwiaGFuZGxlTWVzc2FnZSIsImV2ZW50IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsInByZXYiLCJ0eXBlIiwiY3VycmVudCIsInJlYWR5U3RhdGUiLCJXZWJTb2NrZXQiLCJPUEVOIiwic2VuZCIsInN0cmluZ2lmeSIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlYWRpbmciLCJzdGF0dXMiLCJhbGVydFR5cGUiLCJtZXNzYWdlIiwiZHVyYXRpb24iLCJpY29uIiwiY29uc29sZSIsImxvZyIsImhhbmRsZU9wZW4iLCJzdWNjZXNzIiwiaGFuZGxlRXJyb3IiLCJoYW5kbGVDbG9zZSIsImNvZGUiLCJyZWFzb24iLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xvc2UiLCJ3cyIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiRXJyb3IiLCJjb25uZWN0IiwiZGlzY29ubmVjdCIsInNlbmRNZXNzYWdlIiwicmVjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts\n"));

/***/ })

});