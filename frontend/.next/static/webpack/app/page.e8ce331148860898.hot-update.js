"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts":
/*!*****************************************!*\
  !*** ./src/hooks/useOphiraWebSocket.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOphiraWebSocket: function() { return /* binding */ useOphiraWebSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/medicalStore */ \"(app-pages-browser)/./src/stores/medicalStore.ts\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\nfunction useOphiraWebSocket() {\n    let { enabled = true, sessionId, autoReconnect = true, reconnectInterval = 5000, maxReconnectAttempts = 3 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        connectionStatus: \"disconnected\",\n        lastMessage: null,\n        error: null\n    });\n    const websocketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isManuallyClosedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Medical store actions\n    const { updateVitalSigns, addSensorReading, updateSensorStatus, addAlert, addHealthAnalysis } = (0,_stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__.useMedicalStore)();\n    // Handle incoming WebSocket messages\n    const handleMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        try {\n            const data = JSON.parse(event.data);\n            setState((prev)=>({\n                    ...prev,\n                    lastMessage: data\n                }));\n            // Route messages to appropriate store actions\n            switch(data.type){\n                case \"ping\":\n                    // Respond to server ping with pong\n                    if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\n                        websocketRef.current.send(JSON.stringify({\n                            type: \"pong\",\n                            timestamp: new Date().toISOString()\n                        }));\n                    }\n                    break;\n                case \"vital_signs\":\n                    if (data.data) {\n                        updateVitalSigns(data.data);\n                    }\n                    break;\n                case \"sensor_update\":\n                    if (data.data) {\n                        if (data.data.reading) {\n                            addSensorReading(data.data.reading);\n                        }\n                        if (data.data.status) {\n                            updateSensorStatus(data.data.status);\n                        }\n                    }\n                    break;\n                case \"alert\":\n                    if (data.data) {\n                        addAlert(data.data);\n                        // Show toast notification for alerts\n                        const alertType = data.data.type || \"info\";\n                        const message = data.data.message || \"New medical alert\";\n                        if (alertType === \"critical\" || alertType === \"emergency\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 10000,\n                                icon: \"\\uD83D\\uDEA8\"\n                            });\n                        } else if (alertType === \"warning\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 6000,\n                                icon: \"⚠️\"\n                            });\n                        } else {\n                            (0,react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(message, {\n                                duration: 4000,\n                                icon: \"ℹ️\"\n                            });\n                        }\n                    }\n                    break;\n                case \"chat_message\":\n                    // Handle chat messages (could be routed to a chat store)\n                    console.log(\"Chat message received:\", data.data);\n                    break;\n                case \"agent_status\":\n                    // Handle agent status updates\n                    console.log(\"Agent status update:\", data.data);\n                    break;\n                default:\n                    console.log(\"Unknown WebSocket message type:\", data.type);\n            }\n        } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n        }\n    }, [\n        updateVitalSigns,\n        addSensorReading,\n        updateSensorStatus,\n        addAlert,\n        addHealthAnalysis\n    ]);\n    // Connect to WebSocket\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!enabled || !sessionId || isConnectingRef.current) return;\n        // Close existing connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n        }\n        isConnectingRef.current = true;\n        setState((prev)=>({\n                ...prev,\n                connectionStatus: \"connecting\",\n                error: null\n            }));\n        try {\n            const ws = (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createWebSocketConnection)(sessionId);\n            ws.onopen = ()=>{\n                console.log(\"WebSocket connected\");\n                isConnectingRef.current = false;\n                setState((prev)=>({\n                        ...prev,\n                        isConnected: true,\n                        connectionStatus: \"connected\",\n                        error: null\n                    }));\n                // Reset reconnection attempts on successful connection\n                reconnectAttemptsRef.current = 0;\n                // Only show success toast if we were previously disconnected\n                if (reconnectAttemptsRef.current > 0) {\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].success(\"Reconnected to Ophira AI\", {\n                        duration: 2000,\n                        icon: \"\\uD83D\\uDD17\"\n                    });\n                }\n            };\n            ws.onmessage = handleMessage;\n            ws.onerror = (event)=>{\n                console.error(\"WebSocket error:\", event);\n                isConnectingRef.current = false;\n                // Only update state if we're not already in an error state to prevent loops\n                setState((prev)=>{\n                    if (prev.connectionStatus !== \"error\") {\n                        return {\n                            ...prev,\n                            error: \"WebSocket connection error\",\n                            connectionStatus: \"error\"\n                        };\n                    }\n                    return prev;\n                });\n            };\n            ws.onclose = (event)=>{\n                console.log(\"WebSocket closed:\", event.code, event.reason);\n                isConnectingRef.current = false;\n                setState((prev)=>({\n                        ...prev,\n                        isConnected: false,\n                        connectionStatus: \"disconnected\"\n                    }));\n                // Only attempt reconnection if conditions are met\n                if (!isManuallyClosedRef.current && autoReconnect && enabled && sessionId && reconnectAttemptsRef.current < maxReconnectAttempts && event.code !== 1000) {\n                    setState((prev)=>({\n                            ...prev,\n                            connectionStatus: \"reconnecting\"\n                        }));\n                    // Clear any existing timeout\n                    if (reconnectTimeoutRef.current) {\n                        clearTimeout(reconnectTimeoutRef.current);\n                    }\n                    reconnectTimeoutRef.current = setTimeout(()=>{\n                        reconnectAttemptsRef.current += 1;\n                        console.log(\"Attempting to reconnect... (\".concat(reconnectAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \")\"));\n                        connect();\n                    }, reconnectInterval * Math.pow(2, reconnectAttemptsRef.current)); // Exponential backoff\n                } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n                    console.error(\"Max reconnection attempts reached\");\n                    setState((prev)=>({\n                            ...prev,\n                            error: \"Failed to reconnect after maximum attempts\",\n                            connectionStatus: \"error\"\n                        }));\n                }\n            };\n            websocketRef.current = ws;\n            isManuallyClosedRef.current = false;\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            isConnectingRef.current = false;\n            setState((prev)=>({\n                    ...prev,\n                    error: error instanceof Error ? error.message : \"Failed to connect\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        enabled,\n        sessionId,\n        handleMessage,\n        autoReconnect,\n        maxReconnectAttempts,\n        reconnectInterval\n    ]);\n    // Disconnect from WebSocket\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        isManuallyClosedRef.current = true;\n        isConnectingRef.current = false;\n        // Clear reconnection timeout\n        if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n            reconnectTimeoutRef.current = null;\n        }\n        // Close WebSocket connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n    }, []);\n    // Send message through WebSocket\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        if (websocketRef.current && state.isConnected) {\n            try {\n                websocketRef.current.send(JSON.stringify(message));\n                return true;\n            } catch (error) {\n                console.error(\"Failed to send WebSocket message:\", error);\n                return false;\n            }\n        }\n        return false;\n    }, [\n        state.isConnected\n    ]);\n    // Effect to handle connection lifecycle\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (enabled && sessionId) {\n            connect();\n        } else {\n            disconnect();\n        }\n        // Cleanup on unmount\n        return ()=>{\n            disconnect();\n        };\n    }, [\n        enabled,\n        sessionId,\n        connect,\n        disconnect\n    ]);\n    // Cleanup timeouts on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n            }\n        };\n    }, []);\n    return {\n        ...state,\n        connect,\n        disconnect,\n        sendMessage,\n        reconnect: ()=>{\n            reconnectAttemptsRef.current = 0;\n            connect();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBRVQ7QUFDRjtBQUNsQjtBQWlCN0IsU0FBU087UUFBbUIsRUFDakNDLFVBQVUsSUFBSSxFQUNkQyxTQUFTLEVBQ1RDLGdCQUFnQixJQUFJLEVBQ3BCQyxvQkFBb0IsSUFBSSxFQUN4QkMsdUJBQXVCLENBQUMsRUFDRSxHQU5PLGlFQU1KLENBQUM7SUFDOUIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFpQjtRQUNqRGEsYUFBYTtRQUNiQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsZUFBZWxCLDZDQUFNQSxDQUFtQjtJQUM5QyxNQUFNbUIsc0JBQXNCbkIsNkNBQU1BLENBQXdCO0lBQzFELE1BQU1vQix1QkFBdUJwQiw2Q0FBTUEsQ0FBQztJQUNwQyxNQUFNcUIsc0JBQXNCckIsNkNBQU1BLENBQUM7SUFDbkMsTUFBTXNCLGtCQUFrQnRCLDZDQUFNQSxDQUFDO0lBRS9CLHdCQUF3QjtJQUN4QixNQUFNLEVBQ0p1QixnQkFBZ0IsRUFDaEJDLGdCQUFnQixFQUNoQkMsa0JBQWtCLEVBQ2xCQyxRQUFRLEVBQ1JDLGlCQUFpQixFQUNsQixHQUFHeEIscUVBQWVBO0lBRW5CLHFDQUFxQztJQUNyQyxNQUFNeUIsZ0JBQWdCMUIsa0RBQVdBLENBQUMsQ0FBQzJCO1FBQ2pDLElBQUk7WUFDRixNQUFNQyxPQUF1QkMsS0FBS0MsS0FBSyxDQUFDSCxNQUFNQyxJQUFJO1lBRWxEakIsU0FBU29CLENBQUFBLE9BQVM7b0JBQ2hCLEdBQUdBLElBQUk7b0JBQ1BqQixhQUFhYztnQkFDZjtZQUVBLDhDQUE4QztZQUM5QyxPQUFRQSxLQUFLSSxJQUFJO2dCQUNmLEtBQUs7b0JBQ0gsbUNBQW1DO29CQUNuQyxJQUFJaEIsYUFBYWlCLE9BQU8sSUFBSWpCLGFBQWFpQixPQUFPLENBQUNDLFVBQVUsS0FBS0MsVUFBVUMsSUFBSSxFQUFFO3dCQUM5RXBCLGFBQWFpQixPQUFPLENBQUNJLElBQUksQ0FBQ1IsS0FBS1MsU0FBUyxDQUFDOzRCQUN2Q04sTUFBTTs0QkFDTk8sV0FBVyxJQUFJQyxPQUFPQyxXQUFXO3dCQUNuQztvQkFDRjtvQkFDQTtnQkFFRixLQUFLO29CQUNILElBQUliLEtBQUtBLElBQUksRUFBRTt3QkFDYlAsaUJBQWlCTyxLQUFLQSxJQUFJO29CQUM1QjtvQkFDQTtnQkFFRixLQUFLO29CQUNILElBQUlBLEtBQUtBLElBQUksRUFBRTt3QkFDYixJQUFJQSxLQUFLQSxJQUFJLENBQUNjLE9BQU8sRUFBRTs0QkFDckJwQixpQkFBaUJNLEtBQUtBLElBQUksQ0FBQ2MsT0FBTzt3QkFDcEM7d0JBQ0EsSUFBSWQsS0FBS0EsSUFBSSxDQUFDZSxNQUFNLEVBQUU7NEJBQ3BCcEIsbUJBQW1CSyxLQUFLQSxJQUFJLENBQUNlLE1BQU07d0JBQ3JDO29CQUNGO29CQUNBO2dCQUVGLEtBQUs7b0JBQ0gsSUFBSWYsS0FBS0EsSUFBSSxFQUFFO3dCQUNiSixTQUFTSSxLQUFLQSxJQUFJO3dCQUVsQixxQ0FBcUM7d0JBQ3JDLE1BQU1nQixZQUFZaEIsS0FBS0EsSUFBSSxDQUFDSSxJQUFJLElBQUk7d0JBQ3BDLE1BQU1hLFVBQVVqQixLQUFLQSxJQUFJLENBQUNpQixPQUFPLElBQUk7d0JBRXJDLElBQUlELGNBQWMsY0FBY0EsY0FBYyxhQUFhOzRCQUN6RHpDLHVEQUFLQSxDQUFDWSxLQUFLLENBQUM4QixTQUFTO2dDQUNuQkMsVUFBVTtnQ0FDVkMsTUFBTTs0QkFDUjt3QkFDRixPQUFPLElBQUlILGNBQWMsV0FBVzs0QkFDbEN6Qyx1REFBS0EsQ0FBQ1ksS0FBSyxDQUFDOEIsU0FBUztnQ0FDbkJDLFVBQVU7Z0NBQ1ZDLE1BQU07NEJBQ1I7d0JBQ0YsT0FBTzs0QkFDTDVDLDJEQUFLQSxDQUFDMEMsU0FBUztnQ0FDYkMsVUFBVTtnQ0FDVkMsTUFBTTs0QkFDUjt3QkFDRjtvQkFDRjtvQkFDQTtnQkFFRixLQUFLO29CQUNILHlEQUF5RDtvQkFDekRDLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJyQixLQUFLQSxJQUFJO29CQUMvQztnQkFFRixLQUFLO29CQUNILDhCQUE4QjtvQkFDOUJvQixRQUFRQyxHQUFHLENBQUMsd0JBQXdCckIsS0FBS0EsSUFBSTtvQkFDN0M7Z0JBRUY7b0JBQ0VvQixRQUFRQyxHQUFHLENBQUMsbUNBQW1DckIsS0FBS0ksSUFBSTtZQUM1RDtRQUNGLEVBQUUsT0FBT2pCLE9BQU87WUFDZGlDLFFBQVFqQyxLQUFLLENBQUMsc0NBQXNDQTtRQUN0RDtJQUNGLEdBQUc7UUFBQ007UUFBa0JDO1FBQWtCQztRQUFvQkM7UUFBVUM7S0FBa0I7SUFFeEYsdUJBQXVCO0lBQ3ZCLE1BQU15QixVQUFVbEQsa0RBQVdBLENBQUM7UUFDMUIsSUFBSSxDQUFDSyxXQUFXLENBQUNDLGFBQWFjLGdCQUFnQmEsT0FBTyxFQUFFO1FBRXZELDRCQUE0QjtRQUM1QixJQUFJakIsYUFBYWlCLE9BQU8sRUFBRTtZQUN4QmpCLGFBQWFpQixPQUFPLENBQUNrQixLQUFLO1FBQzVCO1FBRUEvQixnQkFBZ0JhLE9BQU8sR0FBRztRQUMxQnRCLFNBQVNvQixDQUFBQSxPQUFTO2dCQUNoQixHQUFHQSxJQUFJO2dCQUNQbEIsa0JBQWtCO2dCQUNsQkUsT0FBTztZQUNUO1FBRUEsSUFBSTtZQUNGLE1BQU1xQyxLQUFLbEQsbUVBQXlCQSxDQUFDSTtZQUVyQzhDLEdBQUdDLE1BQU0sR0FBRztnQkFDVkwsUUFBUUMsR0FBRyxDQUFDO2dCQUNaN0IsZ0JBQWdCYSxPQUFPLEdBQUc7Z0JBQzFCdEIsU0FBU29CLENBQUFBLE9BQVM7d0JBQ2hCLEdBQUdBLElBQUk7d0JBQ1BuQixhQUFhO3dCQUNiQyxrQkFBa0I7d0JBQ2xCRSxPQUFPO29CQUNUO2dCQUVBLHVEQUF1RDtnQkFDdkRHLHFCQUFxQmUsT0FBTyxHQUFHO2dCQUUvQiw2REFBNkQ7Z0JBQzdELElBQUlmLHFCQUFxQmUsT0FBTyxHQUFHLEdBQUc7b0JBQ3BDOUIsdURBQUtBLENBQUNtRCxPQUFPLENBQUMsNEJBQTRCO3dCQUN4Q1IsVUFBVTt3QkFDVkMsTUFBTTtvQkFDUjtnQkFDRjtZQUNGO1lBRUFLLEdBQUdHLFNBQVMsR0FBRzdCO1lBRWYwQixHQUFHSSxPQUFPLEdBQUcsQ0FBQzdCO2dCQUNacUIsUUFBUWpDLEtBQUssQ0FBQyxvQkFBb0JZO2dCQUNsQ1AsZ0JBQWdCYSxPQUFPLEdBQUc7Z0JBRTFCLDRFQUE0RTtnQkFDNUV0QixTQUFTb0IsQ0FBQUE7b0JBQ1AsSUFBSUEsS0FBS2xCLGdCQUFnQixLQUFLLFNBQVM7d0JBQ3JDLE9BQU87NEJBQ0wsR0FBR2tCLElBQUk7NEJBQ1BoQixPQUFPOzRCQUNQRixrQkFBa0I7d0JBQ3BCO29CQUNGO29CQUNBLE9BQU9rQjtnQkFDVDtZQUNGO1lBRUFxQixHQUFHSyxPQUFPLEdBQUcsQ0FBQzlCO2dCQUNacUIsUUFBUUMsR0FBRyxDQUFDLHFCQUFxQnRCLE1BQU0rQixJQUFJLEVBQUUvQixNQUFNZ0MsTUFBTTtnQkFDekR2QyxnQkFBZ0JhLE9BQU8sR0FBRztnQkFFMUJ0QixTQUFTb0IsQ0FBQUEsT0FBUzt3QkFDaEIsR0FBR0EsSUFBSTt3QkFDUG5CLGFBQWE7d0JBQ2JDLGtCQUFrQjtvQkFDcEI7Z0JBRUEsa0RBQWtEO2dCQUNsRCxJQUFJLENBQUNNLG9CQUFvQmMsT0FBTyxJQUM1QjFCLGlCQUNBRixXQUNBQyxhQUNBWSxxQkFBcUJlLE9BQU8sR0FBR3hCLHdCQUMvQmtCLE1BQU0rQixJQUFJLEtBQUssTUFBTTtvQkFFdkIvQyxTQUFTb0IsQ0FBQUEsT0FBUzs0QkFDaEIsR0FBR0EsSUFBSTs0QkFDUGxCLGtCQUFrQjt3QkFDcEI7b0JBRUEsNkJBQTZCO29CQUM3QixJQUFJSSxvQkFBb0JnQixPQUFPLEVBQUU7d0JBQy9CMkIsYUFBYTNDLG9CQUFvQmdCLE9BQU87b0JBQzFDO29CQUVBaEIsb0JBQW9CZ0IsT0FBTyxHQUFHNEIsV0FBVzt3QkFDdkMzQyxxQkFBcUJlLE9BQU8sSUFBSTt3QkFDaENlLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0R4QyxPQUFoQ1MscUJBQXFCZSxPQUFPLEVBQUMsS0FBd0IsT0FBckJ4QixzQkFBcUI7d0JBQ2hHeUM7b0JBQ0YsR0FBRzFDLG9CQUFvQnNELEtBQUtDLEdBQUcsQ0FBQyxHQUFHN0MscUJBQXFCZSxPQUFPLElBQUksc0JBQXNCO2dCQUMzRixPQUFPLElBQUlmLHFCQUFxQmUsT0FBTyxJQUFJeEIsc0JBQXNCO29CQUMvRHVDLFFBQVFqQyxLQUFLLENBQUM7b0JBQ2RKLFNBQVNvQixDQUFBQSxPQUFTOzRCQUNoQixHQUFHQSxJQUFJOzRCQUNQaEIsT0FBTzs0QkFDUEYsa0JBQWtCO3dCQUNwQjtnQkFDRjtZQUNGO1lBRUFHLGFBQWFpQixPQUFPLEdBQUdtQjtZQUN2QmpDLG9CQUFvQmMsT0FBTyxHQUFHO1FBRWhDLEVBQUUsT0FBT2xCLE9BQU87WUFDZGlDLFFBQVFqQyxLQUFLLENBQUMsMENBQTBDQTtZQUN4REssZ0JBQWdCYSxPQUFPLEdBQUc7WUFDMUJ0QixTQUFTb0IsQ0FBQUEsT0FBUztvQkFDaEIsR0FBR0EsSUFBSTtvQkFDUGhCLE9BQU9BLGlCQUFpQmlELFFBQVFqRCxNQUFNOEIsT0FBTyxHQUFHO29CQUNoRGhDLGtCQUFrQjtnQkFDcEI7UUFDRjtJQUNGLEdBQUc7UUFBQ1I7UUFBU0M7UUFBV29CO1FBQWVuQjtRQUFlRTtRQUFzQkQ7S0FBa0I7SUFFOUYsNEJBQTRCO0lBQzVCLE1BQU15RCxhQUFhakUsa0RBQVdBLENBQUM7UUFDN0JtQixvQkFBb0JjLE9BQU8sR0FBRztRQUM5QmIsZ0JBQWdCYSxPQUFPLEdBQUc7UUFFMUIsNkJBQTZCO1FBQzdCLElBQUloQixvQkFBb0JnQixPQUFPLEVBQUU7WUFDL0IyQixhQUFhM0Msb0JBQW9CZ0IsT0FBTztZQUN4Q2hCLG9CQUFvQmdCLE9BQU8sR0FBRztRQUNoQztRQUVBLDZCQUE2QjtRQUM3QixJQUFJakIsYUFBYWlCLE9BQU8sRUFBRTtZQUN4QmpCLGFBQWFpQixPQUFPLENBQUNrQixLQUFLO1lBQzFCbkMsYUFBYWlCLE9BQU8sR0FBRztRQUN6QjtRQUVBdEIsU0FBU29CLENBQUFBLE9BQVM7Z0JBQ2hCLEdBQUdBLElBQUk7Z0JBQ1BuQixhQUFhO2dCQUNiQyxrQkFBa0I7WUFDcEI7SUFDRixHQUFHLEVBQUU7SUFFTCxpQ0FBaUM7SUFDakMsTUFBTXFELGNBQWNsRSxrREFBV0EsQ0FBQyxDQUFDNkM7UUFDL0IsSUFBSTdCLGFBQWFpQixPQUFPLElBQUl2QixNQUFNRSxXQUFXLEVBQUU7WUFDN0MsSUFBSTtnQkFDRkksYUFBYWlCLE9BQU8sQ0FBQ0ksSUFBSSxDQUFDUixLQUFLUyxTQUFTLENBQUNPO2dCQUN6QyxPQUFPO1lBQ1QsRUFBRSxPQUFPOUIsT0FBTztnQkFDZGlDLFFBQVFqQyxLQUFLLENBQUMscUNBQXFDQTtnQkFDbkQsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1QsR0FBRztRQUFDTCxNQUFNRSxXQUFXO0tBQUM7SUFFdEIsd0NBQXdDO0lBQ3hDZixnREFBU0EsQ0FBQztRQUNSLElBQUlRLFdBQVdDLFdBQVc7WUFDeEI0QztRQUNGLE9BQU87WUFDTGU7UUFDRjtRQUVBLHFCQUFxQjtRQUNyQixPQUFPO1lBQ0xBO1FBQ0Y7SUFDRixHQUFHO1FBQUM1RDtRQUFTQztRQUFXNEM7UUFBU2U7S0FBVztJQUU1Qyw4QkFBOEI7SUFDOUJwRSxnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTCxJQUFJb0Isb0JBQW9CZ0IsT0FBTyxFQUFFO2dCQUMvQjJCLGFBQWEzQyxvQkFBb0JnQixPQUFPO1lBQzFDO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0wsR0FBR3ZCLEtBQUs7UUFDUndDO1FBQ0FlO1FBQ0FDO1FBQ0FDLFdBQVc7WUFDVGpELHFCQUFxQmUsT0FBTyxHQUFHO1lBQy9CaUI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU9waGlyYVdlYlNvY2tldC50cz80YmUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBXZWJTb2NrZXRFdmVudCB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgdXNlTWVkaWNhbFN0b3JlIH0gZnJvbSAnQC9zdG9yZXMvbWVkaWNhbFN0b3JlJztcbmltcG9ydCB7IGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24gfSBmcm9tICdAL2xpYi9hcGknO1xuaW1wb3J0IHRvYXN0IGZyb20gJ3JlYWN0LWhvdC10b2FzdCc7XG5cbmludGVyZmFjZSBVc2VPcGhpcmFXZWJTb2NrZXRPcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIHNlc3Npb25JZD86IHN0cmluZztcbiAgYXV0b1JlY29ubmVjdD86IGJvb2xlYW47XG4gIHJlY29ubmVjdEludGVydmFsPzogbnVtYmVyO1xuICBtYXhSZWNvbm5lY3RBdHRlbXB0cz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFdlYlNvY2tldFN0YXRlIHtcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIGNvbm5lY3Rpb25TdGF0dXM6ICdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCcgfCAnZXJyb3InIHwgJ3JlY29ubmVjdGluZyc7XG4gIGxhc3RNZXNzYWdlOiBXZWJTb2NrZXRFdmVudCB8IG51bGw7XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlT3BoaXJhV2ViU29ja2V0KHtcbiAgZW5hYmxlZCA9IHRydWUsXG4gIHNlc3Npb25JZCxcbiAgYXV0b1JlY29ubmVjdCA9IHRydWUsXG4gIHJlY29ubmVjdEludGVydmFsID0gNTAwMCxcbiAgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAzXG59OiBVc2VPcGhpcmFXZWJTb2NrZXRPcHRpb25zID0ge30pIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXZWJTb2NrZXRTdGF0ZT4oe1xuICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJyxcbiAgICBsYXN0TWVzc2FnZTogbnVsbCxcbiAgICBlcnJvcjogbnVsbFxuICB9KTtcblxuICBjb25zdCB3ZWJzb2NrZXRSZWYgPSB1c2VSZWY8V2ViU29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlY29ubmVjdFRpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVjb25uZWN0QXR0ZW1wdHNSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGlzTWFudWFsbHlDbG9zZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc0Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIC8vIE1lZGljYWwgc3RvcmUgYWN0aW9uc1xuICBjb25zdCB7XG4gICAgdXBkYXRlVml0YWxTaWducyxcbiAgICBhZGRTZW5zb3JSZWFkaW5nLFxuICAgIHVwZGF0ZVNlbnNvclN0YXR1cyxcbiAgICBhZGRBbGVydCxcbiAgICBhZGRIZWFsdGhBbmFseXNpc1xuICB9ID0gdXNlTWVkaWNhbFN0b3JlKCk7XG5cbiAgLy8gSGFuZGxlIGluY29taW5nIFdlYlNvY2tldCBtZXNzYWdlc1xuICBjb25zdCBoYW5kbGVNZXNzYWdlID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YTogV2ViU29ja2V0RXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGxhc3RNZXNzYWdlOiBkYXRhXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFJvdXRlIG1lc3NhZ2VzIHRvIGFwcHJvcHJpYXRlIHN0b3JlIGFjdGlvbnNcbiAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BpbmcnOlxuICAgICAgICAgIC8vIFJlc3BvbmQgdG8gc2VydmVyIHBpbmcgd2l0aCBwb25nXG4gICAgICAgICAgaWYgKHdlYnNvY2tldFJlZi5jdXJyZW50ICYmIHdlYnNvY2tldFJlZi5jdXJyZW50LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3BvbmcnLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAndml0YWxfc2lnbnMnOlxuICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIHVwZGF0ZVZpdGFsU2lnbnMoZGF0YS5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ3NlbnNvcl91cGRhdGUnOlxuICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEucmVhZGluZykge1xuICAgICAgICAgICAgICBhZGRTZW5zb3JSZWFkaW5nKGRhdGEuZGF0YS5yZWFkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVNlbnNvclN0YXR1cyhkYXRhLmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ2FsZXJ0JzpcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBhZGRBbGVydChkYXRhLmRhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG93IHRvYXN0IG5vdGlmaWNhdGlvbiBmb3IgYWxlcnRzXG4gICAgICAgICAgICBjb25zdCBhbGVydFR5cGUgPSBkYXRhLmRhdGEudHlwZSB8fCAnaW5mbyc7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZGF0YS5kYXRhLm1lc3NhZ2UgfHwgJ05ldyBtZWRpY2FsIGFsZXJ0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGFsZXJ0VHlwZSA9PT0gJ2NyaXRpY2FsJyB8fCBhbGVydFR5cGUgPT09ICdlbWVyZ2VuY3knKSB7XG4gICAgICAgICAgICAgIHRvYXN0LmVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwMDAsXG4gICAgICAgICAgICAgICAgaWNvbjogJ/CfmqgnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGVydFR5cGUgPT09ICd3YXJuaW5nJykge1xuICAgICAgICAgICAgICB0b2FzdC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDYwMDAsXG4gICAgICAgICAgICAgICAgaWNvbjogJ+KaoO+4jydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b2FzdChtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDQwMDAsXG4gICAgICAgICAgICAgICAgaWNvbjogJ+KEue+4jydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdjaGF0X21lc3NhZ2UnOlxuICAgICAgICAgIC8vIEhhbmRsZSBjaGF0IG1lc3NhZ2VzIChjb3VsZCBiZSByb3V0ZWQgdG8gYSBjaGF0IHN0b3JlKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDaGF0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAnYWdlbnRfc3RhdHVzJzpcbiAgICAgICAgICAvLyBIYW5kbGUgYWdlbnQgc3RhdHVzIHVwZGF0ZXNcbiAgICAgICAgICBjb25zb2xlLmxvZygnQWdlbnQgc3RhdHVzIHVwZGF0ZTonLCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmtub3duIFdlYlNvY2tldCBtZXNzYWdlIHR5cGU6JywgZGF0YS50eXBlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIFdlYlNvY2tldCBtZXNzYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFt1cGRhdGVWaXRhbFNpZ25zLCBhZGRTZW5zb3JSZWFkaW5nLCB1cGRhdGVTZW5zb3JTdGF0dXMsIGFkZEFsZXJ0LCBhZGRIZWFsdGhBbmFseXNpc10pO1xuXG4gIC8vIENvbm5lY3QgdG8gV2ViU29ja2V0XG4gIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFzZXNzaW9uSWQgfHwgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIENsb3NlIGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICBpZiAod2Vic29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGluZycsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB3cyA9IGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24oc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBpc0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgICAgIHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgICAgICBcbiAgICAgICAgLy8gT25seSBzaG93IHN1Y2Nlc3MgdG9hc3QgaWYgd2Ugd2VyZSBwcmV2aW91c2x5IGRpc2Nvbm5lY3RlZFxuICAgICAgICBpZiAocmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA+IDApIHtcbiAgICAgICAgICB0b2FzdC5zdWNjZXNzKCdSZWNvbm5lY3RlZCB0byBPcGhpcmEgQUknLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMjAwMCxcbiAgICAgICAgICAgIGljb246ICfwn5SXJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB3cy5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuICAgICAgXG4gICAgICB3cy5vbmVycm9yID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXZlbnQpO1xuICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gT25seSB1cGRhdGUgc3RhdGUgaWYgd2UncmUgbm90IGFscmVhZHkgaW4gYW4gZXJyb3Igc3RhdGUgdG8gcHJldmVudCBsb29wc1xuICAgICAgICBzZXRTdGF0ZShwcmV2ID0+IHtcbiAgICAgICAgICBpZiAocHJldi5jb25uZWN0aW9uU3RhdHVzICE9PSAnZXJyb3InKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICBlcnJvcjogJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yJyxcbiAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Vycm9yJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgd3Mub25jbG9zZSA9IChldmVudDogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNsb3NlZDonLCBldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xuICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyBPbmx5IGF0dGVtcHQgcmVjb25uZWN0aW9uIGlmIGNvbmRpdGlvbnMgYXJlIG1ldFxuICAgICAgICBpZiAoIWlzTWFudWFsbHlDbG9zZWRSZWYuY3VycmVudCAmJiBcbiAgICAgICAgICAgIGF1dG9SZWNvbm5lY3QgJiYgXG4gICAgICAgICAgICBlbmFibGVkICYmIFxuICAgICAgICAgICAgc2Vzc2lvbklkICYmXG4gICAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50IDwgbWF4UmVjb25uZWN0QXR0ZW1wdHMgJiZcbiAgICAgICAgICAgIGV2ZW50LmNvZGUgIT09IDEwMDApIHsgLy8gRG9uJ3QgcmVjb25uZWN0IG9uIG5vcm1hbCBjbG9zdXJlXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdyZWNvbm5lY3RpbmcnXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCArPSAxO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0Li4uICgke3JlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnR9LyR7bWF4UmVjb25uZWN0QXR0ZW1wdHN9KWApO1xuICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICAgIH0sIHJlY29ubmVjdEludGVydmFsICogTWF0aC5wb3coMiwgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCkpOyAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA+PSBtYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xuICAgICAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgbWF4aW11bSBhdHRlbXB0cycsXG4gICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudCA9IHdzO1xuICAgICAgaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQgY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGNvbm5lY3QnLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZXJyb3InXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgc2Vzc2lvbklkLCBoYW5kbGVNZXNzYWdlLCBhdXRvUmVjb25uZWN0LCBtYXhSZWNvbm5lY3RBdHRlbXB0cywgcmVjb25uZWN0SW50ZXJ2YWxdKTtcblxuICAvLyBEaXNjb25uZWN0IGZyb20gV2ViU29ja2V0XG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIFxuICAgIC8vIENsZWFyIHJlY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbG9zZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgLy8gU2VuZCBtZXNzYWdlIHRocm91Z2ggV2ViU29ja2V0XG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCAmJiBzdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlbmQgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW3N0YXRlLmlzQ29ubmVjdGVkXSk7XG5cbiAgLy8gRWZmZWN0IHRvIGhhbmRsZSBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmIHNlc3Npb25JZCkge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgc2Vzc2lvbklkLCBjb25uZWN0LCBkaXNjb25uZWN0XSk7XG5cbiAgLy8gQ2xlYW51cCB0aW1lb3V0cyBvbiB1bm1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgY29ubmVjdCxcbiAgICBkaXNjb25uZWN0LFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIHJlY29ubmVjdDogKCkgPT4ge1xuICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lZGljYWxTdG9yZSIsImNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24iLCJ0b2FzdCIsInVzZU9waGlyYVdlYlNvY2tldCIsImVuYWJsZWQiLCJzZXNzaW9uSWQiLCJhdXRvUmVjb25uZWN0IiwicmVjb25uZWN0SW50ZXJ2YWwiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsInN0YXRlIiwic2V0U3RhdGUiLCJpc0Nvbm5lY3RlZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJsYXN0TWVzc2FnZSIsImVycm9yIiwid2Vic29ja2V0UmVmIiwicmVjb25uZWN0VGltZW91dFJlZiIsInJlY29ubmVjdEF0dGVtcHRzUmVmIiwiaXNNYW51YWxseUNsb3NlZFJlZiIsImlzQ29ubmVjdGluZ1JlZiIsInVwZGF0ZVZpdGFsU2lnbnMiLCJhZGRTZW5zb3JSZWFkaW5nIiwidXBkYXRlU2Vuc29yU3RhdHVzIiwiYWRkQWxlcnQiLCJhZGRIZWFsdGhBbmFseXNpcyIsImhhbmRsZU1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJwcmV2IiwidHlwZSIsImN1cnJlbnQiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsInNlbmQiLCJzdHJpbmdpZnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZWFkaW5nIiwic3RhdHVzIiwiYWxlcnRUeXBlIiwibWVzc2FnZSIsImR1cmF0aW9uIiwiaWNvbiIsImNvbnNvbGUiLCJsb2ciLCJjb25uZWN0IiwiY2xvc2UiLCJ3cyIsIm9ub3BlbiIsInN1Y2Nlc3MiLCJvbm1lc3NhZ2UiLCJvbmVycm9yIiwib25jbG9zZSIsImNvZGUiLCJyZWFzb24iLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiTWF0aCIsInBvdyIsIkVycm9yIiwiZGlzY29ubmVjdCIsInNlbmRNZXNzYWdlIiwicmVjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts\n"));

/***/ })

});