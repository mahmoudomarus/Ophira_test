"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts":
/*!*****************************************!*\
  !*** ./src/hooks/useOphiraWebSocket.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOphiraWebSocket: function() { return /* binding */ useOphiraWebSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/medicalStore */ \"(app-pages-browser)/./src/stores/medicalStore.ts\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\nfunction useOphiraWebSocket() {\n    let { enabled = true, sessionId, autoReconnect = true, reconnectInterval = 5000, maxReconnectAttempts = 5 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        connectionStatus: \"disconnected\",\n        lastMessage: null,\n        error: null\n    });\n    const websocketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isManuallyClosedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Medical store actions\n    const { updateVitalSigns, addSensorReading, updateSensorStatus, addAlert, addHealthAnalysis } = (0,_stores_medicalStore__WEBPACK_IMPORTED_MODULE_1__.useMedicalStore)();\n    // Handle incoming WebSocket messages\n    const handleMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        try {\n            const data = JSON.parse(event.data);\n            setState((prev)=>({\n                    ...prev,\n                    lastMessage: data\n                }));\n            // Route messages to appropriate store actions\n            switch(data.type){\n                case \"ping\":\n                    // Respond to server ping with pong\n                    if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\n                        websocketRef.current.send(JSON.stringify({\n                            type: \"pong\",\n                            timestamp: new Date().toISOString()\n                        }));\n                    }\n                    break;\n                case \"vital_signs\":\n                    if (data.data) {\n                        updateVitalSigns(data.data);\n                    }\n                    break;\n                case \"sensor_update\":\n                    if (data.data) {\n                        if (data.data.reading) {\n                            addSensorReading(data.data.reading);\n                        }\n                        if (data.data.status) {\n                            updateSensorStatus(data.data.status);\n                        }\n                    }\n                    break;\n                case \"alert\":\n                    if (data.data) {\n                        addAlert(data.data);\n                        // Show toast notification for alerts\n                        const alertType = data.data.type || \"info\";\n                        const message = data.data.message || \"New medical alert\";\n                        if (alertType === \"critical\" || alertType === \"emergency\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 10000,\n                                icon: \"\\uD83D\\uDEA8\"\n                            });\n                        } else if (alertType === \"warning\") {\n                            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(message, {\n                                duration: 6000,\n                                icon: \"⚠️\"\n                            });\n                        } else {\n                            (0,react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(message, {\n                                duration: 4000,\n                                icon: \"ℹ️\"\n                            });\n                        }\n                    }\n                    break;\n                case \"chat_message\":\n                    // Handle chat messages (could be routed to a chat store)\n                    console.log(\"Chat message received:\", data.data);\n                    break;\n                case \"agent_status\":\n                    // Handle agent status updates\n                    console.log(\"Agent status update:\", data.data);\n                    break;\n                default:\n                    console.log(\"Unknown WebSocket message type:\", data.type);\n            }\n        } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n        }\n    }, [\n        updateVitalSigns,\n        addSensorReading,\n        updateSensorStatus,\n        addAlert,\n        addHealthAnalysis\n    ]);\n    // Handle WebSocket connection open\n    const handleOpen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"WebSocket connected\");\n        setState((prev)=>({\n                ...prev,\n                isConnected: true,\n                connectionStatus: \"connected\",\n                error: null\n            }));\n        // Reset reconnection attempts on successful connection\n        reconnectAttemptsRef.current = 0;\n        react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].success(\"Connected to Ophira AI\", {\n            duration: 3000,\n            icon: \"\\uD83D\\uDD17\"\n        });\n    }, []);\n    // Handle WebSocket errors\n    const handleError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.error(\"WebSocket error:\", event);\n        // Only update state if we're not already in an error state to prevent loops\n        setState((prev)=>{\n            if (prev.connectionStatus !== \"error\") {\n                return {\n                    ...prev,\n                    error: \"WebSocket connection error\",\n                    connectionStatus: \"error\"\n                };\n            }\n            return prev;\n        });\n    }, []);\n    // Handle WebSocket connection close\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        console.log(\"WebSocket closed:\", event.code, event.reason);\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n        // Only attempt reconnection if not manually closed and auto-reconnect is enabled\n        // Add additional checks to prevent infinite loops\n        if (!isManuallyClosedRef.current && autoReconnect && enabled && sessionId && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            // Only try to reconnect if the close wasn't due to an error state\n            if (event.code !== 1006 && event.code !== 1000) {\n                setState((prev)=>({\n                        ...prev,\n                        connectionStatus: \"reconnecting\"\n                    }));\n                // Clear any existing timeout\n                if (reconnectTimeoutRef.current) {\n                    clearTimeout(reconnectTimeoutRef.current);\n                }\n                reconnectTimeoutRef.current = setTimeout(()=>{\n                    reconnectAttemptsRef.current += 1;\n                    console.log(\"Attempting to reconnect... (\".concat(reconnectAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \")\"));\n                    connect();\n                }, reconnectInterval * reconnectAttemptsRef.current); // Exponential backoff\n            }\n        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            console.error(\"Max reconnection attempts reached\");\n            setState((prev)=>({\n                    ...prev,\n                    error: \"Failed to reconnect after maximum attempts\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        autoReconnect,\n        enabled,\n        sessionId,\n        maxReconnectAttempts,\n        reconnectInterval,\n        connect\n    ]);\n    // Connect to WebSocket\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!enabled || !sessionId) return;\n        // Close existing connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n        }\n        setState((prev)=>({\n                ...prev,\n                connectionStatus: \"connecting\",\n                error: null\n            }));\n        try {\n            const ws = (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createWebSocketConnection)(sessionId);\n            ws.onopen = handleOpen;\n            ws.onmessage = handleMessage;\n            ws.onerror = handleError;\n            ws.onclose = handleClose;\n            websocketRef.current = ws;\n            isManuallyClosedRef.current = false;\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    error: error instanceof Error ? error.message : \"Failed to connect\",\n                    connectionStatus: \"error\"\n                }));\n        }\n    }, [\n        enabled,\n        sessionId,\n        handleOpen,\n        handleMessage,\n        handleError,\n        handleClose\n    ]);\n    // Disconnect from WebSocket\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        isManuallyClosedRef.current = true;\n        // Clear reconnection timeout\n        if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n            reconnectTimeoutRef.current = null;\n        }\n        // Close WebSocket connection\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n        setState((prev)=>({\n                ...prev,\n                isConnected: false,\n                connectionStatus: \"disconnected\"\n            }));\n    }, []);\n    // Send message through WebSocket\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        if (websocketRef.current && state.isConnected) {\n            try {\n                websocketRef.current.send(JSON.stringify(message));\n                return true;\n            } catch (error) {\n                console.error(\"Failed to send WebSocket message:\", error);\n                return false;\n            }\n        }\n        return false;\n    }, [\n        state.isConnected\n    ]);\n    // Effect to handle connection lifecycle\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (enabled && sessionId) {\n            connect();\n        } else {\n            disconnect();\n        }\n        // Cleanup on unmount\n        return ()=>{\n            disconnect();\n        };\n    }, [\n        enabled,\n        sessionId,\n        connect,\n        disconnect\n    ]);\n    // Cleanup timeouts on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n            }\n        };\n    }, []);\n    return {\n        ...state,\n        connect,\n        disconnect,\n        sendMessage,\n        reconnect: ()=>{\n            reconnectAttemptsRef.current = 0;\n            connect();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VPcGhpcmFXZWJTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBRVQ7QUFDRjtBQUNsQjtBQWlCN0IsU0FBU087UUFBbUIsRUFDakNDLFVBQVUsSUFBSSxFQUNkQyxTQUFTLEVBQ1RDLGdCQUFnQixJQUFJLEVBQ3BCQyxvQkFBb0IsSUFBSSxFQUN4QkMsdUJBQXVCLENBQUMsRUFDRSxHQU5PLGlFQU1KLENBQUM7SUFDOUIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFpQjtRQUNqRGEsYUFBYTtRQUNiQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsZUFBZWxCLDZDQUFNQSxDQUFtQjtJQUM5QyxNQUFNbUIsc0JBQXNCbkIsNkNBQU1BLENBQXdCO0lBQzFELE1BQU1vQix1QkFBdUJwQiw2Q0FBTUEsQ0FBQztJQUNwQyxNQUFNcUIsc0JBQXNCckIsNkNBQU1BLENBQUM7SUFFbkMsd0JBQXdCO0lBQ3hCLE1BQU0sRUFDSnNCLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxrQkFBa0IsRUFDbEJDLFFBQVEsRUFDUkMsaUJBQWlCLEVBQ2xCLEdBQUd2QixxRUFBZUE7SUFFbkIscUNBQXFDO0lBQ3JDLE1BQU13QixnQkFBZ0J6QixrREFBV0EsQ0FBQyxDQUFDMEI7UUFDakMsSUFBSTtZQUNGLE1BQU1DLE9BQXVCQyxLQUFLQyxLQUFLLENBQUNILE1BQU1DLElBQUk7WUFFbERoQixTQUFTbUIsQ0FBQUEsT0FBUztvQkFDaEIsR0FBR0EsSUFBSTtvQkFDUGhCLGFBQWFhO2dCQUNmO1lBRUEsOENBQThDO1lBQzlDLE9BQVFBLEtBQUtJLElBQUk7Z0JBQ2YsS0FBSztvQkFDSCxtQ0FBbUM7b0JBQ25DLElBQUlmLGFBQWFnQixPQUFPLElBQUloQixhQUFhZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTt3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QSxJQUFJO2dCQUNQbEIsYUFBYTtnQkFDYkMsa0JBQWtCO1lBQ3BCO0lBQ0YsR0FBRyxFQUFFO0lBRUwsaUNBQWlDO0lBQ2pDLE1BQU1xRCxjQUFjbEUsa0RBQVdBLENBQUMsQ0FBQzRDO1FBQy9CLElBQUk1QixhQUFhZ0IsT0FBTyxJQUFJdEIsTUFBTUUsV0FBVyxFQUFFO1lBQzdDLElBQUk7Z0JBQ0ZJLGFBQWFnQixPQUFPLENBQUNJLElBQUksQ0FBQ1IsS0FBS1MsU0FBUyxDQUFDTztnQkFDekMsT0FBTztZQUNULEVBQUUsT0FBTzdCLE9BQU87Z0JBQ2RnQyxRQUFRaEMsS0FBSyxDQUFDLHFDQUFxQ0E7Z0JBQ25ELE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNULEdBQUc7UUFBQ0wsTUFBTUUsV0FBVztLQUFDO0lBRXRCLHdDQUF3QztJQUN4Q2YsZ0RBQVNBLENBQUM7UUFDUixJQUFJUSxXQUFXQyxXQUFXO1lBQ3hCbUQ7UUFDRixPQUFPO1lBQ0xRO1FBQ0Y7UUFFQSxxQkFBcUI7UUFDckIsT0FBTztZQUNMQTtRQUNGO0lBQ0YsR0FBRztRQUFDNUQ7UUFBU0M7UUFBV21EO1FBQVNRO0tBQVc7SUFFNUMsOEJBQThCO0lBQzlCcEUsZ0RBQVNBLENBQUM7UUFDUixPQUFPO1lBQ0wsSUFBSW9CLG9CQUFvQmUsT0FBTyxFQUFFO2dCQUMvQnVCLGFBQWF0QyxvQkFBb0JlLE9BQU87WUFDMUM7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU87UUFDTCxHQUFHdEIsS0FBSztRQUNSK0M7UUFDQVE7UUFDQUM7UUFDQUMsV0FBVztZQUNUakQscUJBQXFCYyxPQUFPLEdBQUc7WUFDL0J5QjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlT3BoaXJhV2ViU29ja2V0LnRzPzRiZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFdlYlNvY2tldEV2ZW50IH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyB1c2VNZWRpY2FsU3RvcmUgfSBmcm9tICdAL3N0b3Jlcy9tZWRpY2FsU3RvcmUnO1xuaW1wb3J0IHsgY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbiB9IGZyb20gJ0AvbGliL2FwaSc7XG5pbXBvcnQgdG9hc3QgZnJvbSAncmVhY3QtaG90LXRvYXN0JztcblxuaW50ZXJmYWNlIFVzZU9waGlyYVdlYlNvY2tldE9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgc2Vzc2lvbklkPzogc3RyaW5nO1xuICBhdXRvUmVjb25uZWN0PzogYm9vbGVhbjtcbiAgcmVjb25uZWN0SW50ZXJ2YWw/OiBudW1iZXI7XG4gIG1heFJlY29ubmVjdEF0dGVtcHRzPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgV2ViU29ja2V0U3RhdGUge1xuICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RpbmcnIHwgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdlcnJvcicgfCAncmVjb25uZWN0aW5nJztcbiAgbGFzdE1lc3NhZ2U6IFdlYlNvY2tldEV2ZW50IHwgbnVsbDtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VPcGhpcmFXZWJTb2NrZXQoe1xuICBlbmFibGVkID0gdHJ1ZSxcbiAgc2Vzc2lvbklkLFxuICBhdXRvUmVjb25uZWN0ID0gdHJ1ZSxcbiAgcmVjb25uZWN0SW50ZXJ2YWwgPSA1MDAwLFxuICBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IDVcbn06IFVzZU9waGlyYVdlYlNvY2tldE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFdlYlNvY2tldFN0YXRlPih7XG4gICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnLFxuICAgIGxhc3RNZXNzYWdlOiBudWxsLFxuICAgIGVycm9yOiBudWxsXG4gIH0pO1xuXG4gIGNvbnN0IHdlYnNvY2tldFJlZiA9IHVzZVJlZjxXZWJTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVjb25uZWN0VGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZWNvbm5lY3RBdHRlbXB0c1JlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgaXNNYW51YWxseUNsb3NlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgLy8gTWVkaWNhbCBzdG9yZSBhY3Rpb25zXG4gIGNvbnN0IHtcbiAgICB1cGRhdGVWaXRhbFNpZ25zLFxuICAgIGFkZFNlbnNvclJlYWRpbmcsXG4gICAgdXBkYXRlU2Vuc29yU3RhdHVzLFxuICAgIGFkZEFsZXJ0LFxuICAgIGFkZEhlYWx0aEFuYWx5c2lzXG4gIH0gPSB1c2VNZWRpY2FsU3RvcmUoKTtcblxuICAvLyBIYW5kbGUgaW5jb21pbmcgV2ViU29ja2V0IG1lc3NhZ2VzXG4gIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhOiBXZWJTb2NrZXRFdmVudCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICBcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgbGFzdE1lc3NhZ2U6IGRhdGFcbiAgICAgIH0pKTtcblxuICAgICAgLy8gUm91dGUgbWVzc2FnZXMgdG8gYXBwcm9wcmlhdGUgc3RvcmUgYWN0aW9uc1xuICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncGluZyc6XG4gICAgICAgICAgLy8gUmVzcG9uZCB0byBzZXJ2ZXIgcGluZyB3aXRoIHBvbmdcbiAgICAgICAgICBpZiAod2Vic29ja2V0UmVmLmN1cnJlbnQgJiYgd2Vic29ja2V0UmVmLmN1cnJlbnQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICB0eXBlOiAncG9uZycsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICd2aXRhbF9zaWducyc6XG4gICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgdXBkYXRlVml0YWxTaWducyhkYXRhLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAnc2Vuc29yX3VwZGF0ZSc6XG4gICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuZGF0YS5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgIGFkZFNlbnNvclJlYWRpbmcoZGF0YS5kYXRhLnJlYWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU2Vuc29yU3RhdHVzKGRhdGEuZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgY2FzZSAnYWxlcnQnOlxuICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIGFkZEFsZXJ0KGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3cgdG9hc3Qgbm90aWZpY2F0aW9uIGZvciBhbGVydHNcbiAgICAgICAgICAgIGNvbnN0IGFsZXJ0VHlwZSA9IGRhdGEuZGF0YS50eXBlIHx8ICdpbmZvJztcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkYXRhLmRhdGEubWVzc2FnZSB8fCAnTmV3IG1lZGljYWwgYWxlcnQnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYWxlcnRUeXBlID09PSAnY3JpdGljYWwnIHx8IGFsZXJ0VHlwZSA9PT0gJ2VtZXJnZW5jeScpIHtcbiAgICAgICAgICAgICAgdG9hc3QuZXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMDAwMCxcbiAgICAgICAgICAgICAgICBpY29uOiAn8J+aqCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsZXJ0VHlwZSA9PT0gJ3dhcm5pbmcnKSB7XG4gICAgICAgICAgICAgIHRvYXN0LmVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNjAwMCxcbiAgICAgICAgICAgICAgICBpY29uOiAn4pqg77iPJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRvYXN0KG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNDAwMCxcbiAgICAgICAgICAgICAgICBpY29uOiAn4oS577iPJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGNhc2UgJ2NoYXRfbWVzc2FnZSc6XG4gICAgICAgICAgLy8gSGFuZGxlIGNoYXQgbWVzc2FnZXMgKGNvdWxkIGJlIHJvdXRlZCB0byBhIGNoYXQgc3RvcmUpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NoYXQgbWVzc2FnZSByZWNlaXZlZDonLCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBjYXNlICdhZ2VudF9zdGF0dXMnOlxuICAgICAgICAgIC8vIEhhbmRsZSBhZ2VudCBzdGF0dXMgdXBkYXRlc1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBZ2VudCBzdGF0dXMgdXBkYXRlOicsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Vua25vd24gV2ViU29ja2V0IG1lc3NhZ2UgdHlwZTonLCBkYXRhLnR5cGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW3VwZGF0ZVZpdGFsU2lnbnMsIGFkZFNlbnNvclJlYWRpbmcsIHVwZGF0ZVNlbnNvclN0YXR1cywgYWRkQWxlcnQsIGFkZEhlYWx0aEFuYWx5c2lzXSk7XG5cbiAgLy8gSGFuZGxlIFdlYlNvY2tldCBjb25uZWN0aW9uIG9wZW5cbiAgY29uc3QgaGFuZGxlT3BlbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBpc0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdjb25uZWN0ZWQnLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KSk7XG4gICAgXG4gICAgLy8gUmVzZXQgcmVjb25uZWN0aW9uIGF0dGVtcHRzIG9uIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICAgIHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgIFxuICAgIHRvYXN0LnN1Y2Nlc3MoJ0Nvbm5lY3RlZCB0byBPcGhpcmEgQUknLCB7XG4gICAgICBkdXJhdGlvbjogMzAwMCxcbiAgICAgIGljb246ICfwn5SXJ1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgLy8gSGFuZGxlIFdlYlNvY2tldCBlcnJvcnNcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGV2ZW50KTtcbiAgICBcbiAgICAvLyBPbmx5IHVwZGF0ZSBzdGF0ZSBpZiB3ZSdyZSBub3QgYWxyZWFkeSBpbiBhbiBlcnJvciBzdGF0ZSB0byBwcmV2ZW50IGxvb3BzXG4gICAgc2V0U3RhdGUocHJldiA9PiB7XG4gICAgICBpZiAocHJldi5jb25uZWN0aW9uU3RhdHVzICE9PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBlcnJvcjogJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yJyxcbiAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZXJyb3InXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIEhhbmRsZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZVxuICBjb25zdCBoYW5kbGVDbG9zZSA9IHVzZUNhbGxiYWNrKChldmVudDogQ2xvc2VFdmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgY2xvc2VkOicsIGV2ZW50LmNvZGUsIGV2ZW50LnJlYXNvbik7XG4gICAgXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgfSkpO1xuXG4gICAgLy8gT25seSBhdHRlbXB0IHJlY29ubmVjdGlvbiBpZiBub3QgbWFudWFsbHkgY2xvc2VkIGFuZCBhdXRvLXJlY29ubmVjdCBpcyBlbmFibGVkXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgY2hlY2tzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICBpZiAoIWlzTWFudWFsbHlDbG9zZWRSZWYuY3VycmVudCAmJiBcbiAgICAgICAgYXV0b1JlY29ubmVjdCAmJiBcbiAgICAgICAgZW5hYmxlZCAmJiBcbiAgICAgICAgc2Vzc2lvbklkICYmXG4gICAgICAgIHJlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnQgPCBtYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgXG4gICAgICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgdGhlIGNsb3NlIHdhc24ndCBkdWUgdG8gYW4gZXJyb3Igc3RhdGVcbiAgICAgIGlmIChldmVudC5jb2RlICE9PSAxMDA2ICYmIGV2ZW50LmNvZGUgIT09IDEwMDApIHtcbiAgICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ3JlY29ubmVjdGluZydcbiAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXRcbiAgICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50ICs9IDE7XG4gICAgICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0Li4uICgke3JlY29ubmVjdEF0dGVtcHRzUmVmLmN1cnJlbnR9LyR7bWF4UmVjb25uZWN0QXR0ZW1wdHN9KWApO1xuICAgICAgICAgIGNvbm5lY3QoKTtcbiAgICAgICAgfSwgcmVjb25uZWN0SW50ZXJ2YWwgKiByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50KTsgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA+PSBtYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgY29uc29sZS5lcnJvcignTWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyByZWFjaGVkJyk7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciBtYXhpbXVtIGF0dGVtcHRzJyxcbiAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Vycm9yJ1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW2F1dG9SZWNvbm5lY3QsIGVuYWJsZWQsIHNlc3Npb25JZCwgbWF4UmVjb25uZWN0QXR0ZW1wdHMsIHJlY29ubmVjdEludGVydmFsLCBjb25uZWN0XSk7XG5cbiAgLy8gQ29ubmVjdCB0byBXZWJTb2NrZXRcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXNlc3Npb25JZCkgcmV0dXJuO1xuXG4gICAgLy8gQ2xvc2UgZXhpc3RpbmcgY29ubmVjdGlvblxuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RpbmcnLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgd3MgPSBjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uKHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIHdzLm9ub3BlbiA9IGhhbmRsZU9wZW47XG4gICAgICB3cy5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuICAgICAgd3Mub25lcnJvciA9IGhhbmRsZUVycm9yO1xuICAgICAgd3Mub25jbG9zZSA9IGhhbmRsZUNsb3NlO1xuICAgICAgXG4gICAgICB3ZWJzb2NrZXRSZWYuY3VycmVudCA9IHdzO1xuICAgICAgaXNNYW51YWxseUNsb3NlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQgY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gY29ubmVjdCcsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdlcnJvcidcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBzZXNzaW9uSWQsIGhhbmRsZU9wZW4sIGhhbmRsZU1lc3NhZ2UsIGhhbmRsZUVycm9yLCBoYW5kbGVDbG9zZV0pO1xuXG4gIC8vIERpc2Nvbm5lY3QgZnJvbSBXZWJTb2NrZXRcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpc01hbnVhbGx5Q2xvc2VkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIFxuICAgIC8vIENsZWFyIHJlY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbG9zZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICAgIHdlYnNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgLy8gU2VuZCBtZXNzYWdlIHRocm91Z2ggV2ViU29ja2V0XG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIGlmICh3ZWJzb2NrZXRSZWYuY3VycmVudCAmJiBzdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2Vic29ja2V0UmVmLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlbmQgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW3N0YXRlLmlzQ29ubmVjdGVkXSk7XG5cbiAgLy8gRWZmZWN0IHRvIGhhbmRsZSBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmIHNlc3Npb25JZCkge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgc2Vzc2lvbklkLCBjb25uZWN0LCBkaXNjb25uZWN0XSk7XG5cbiAgLy8gQ2xlYW51cCB0aW1lb3V0cyBvbiB1bm1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgY29ubmVjdCxcbiAgICBkaXNjb25uZWN0LFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIHJlY29ubmVjdDogKCkgPT4ge1xuICAgICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lZGljYWxTdG9yZSIsImNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24iLCJ0b2FzdCIsInVzZU9waGlyYVdlYlNvY2tldCIsImVuYWJsZWQiLCJzZXNzaW9uSWQiLCJhdXRvUmVjb25uZWN0IiwicmVjb25uZWN0SW50ZXJ2YWwiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsInN0YXRlIiwic2V0U3RhdGUiLCJpc0Nvbm5lY3RlZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJsYXN0TWVzc2FnZSIsImVycm9yIiwid2Vic29ja2V0UmVmIiwicmVjb25uZWN0VGltZW91dFJlZiIsInJlY29ubmVjdEF0dGVtcHRzUmVmIiwiaXNNYW51YWxseUNsb3NlZFJlZiIsInVwZGF0ZVZpdGFsU2lnbnMiLCJhZGRTZW5zb3JSZWFkaW5nIiwidXBkYXRlU2Vuc29yU3RhdHVzIiwiYWRkQWxlcnQiLCJhZGRIZWFsdGhBbmFseXNpcyIsImhhbmRsZU1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJwcmV2IiwidHlwZSIsImN1cnJlbnQiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsInNlbmQiLCJzdHJpbmdpZnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZWFkaW5nIiwic3RhdHVzIiwiYWxlcnRUeXBlIiwibWVzc2FnZSIsImR1cmF0aW9uIiwiaWNvbiIsImNvbnNvbGUiLCJsb2ciLCJoYW5kbGVPcGVuIiwic3VjY2VzcyIsImhhbmRsZUVycm9yIiwiaGFuZGxlQ2xvc2UiLCJjb2RlIiwicmVhc29uIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNvbm5lY3QiLCJjbG9zZSIsIndzIiwib25vcGVuIiwib25tZXNzYWdlIiwib25lcnJvciIsIm9uY2xvc2UiLCJFcnJvciIsImRpc2Nvbm5lY3QiLCJzZW5kTWVzc2FnZSIsInJlY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useOphiraWebSocket.ts\n"));

/***/ })

});